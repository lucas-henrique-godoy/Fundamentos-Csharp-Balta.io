								CURSO DE C# BALTA.IO

O C# é uma linguagem fortemente tipada, de alto nível, compilada e gerenciada. É compilada para uma linguagem intermediária chamada IL, depois disso o gerenciador CLR runtime compila a linguagem intermediária para o código de máquina, executa e faz o gerenciamento da aplicação C#. Isso significa que não precisamos alocar memória, não precisamos nos preocupar com segurança da aplicação. É abstraído a questão de acesso a hardware.
O IL é uma linguagem intermediária em que todas as linguagens da Microsoft são compiladas.
 
O CLR (Common Language Runtime) é o ambiente de execução do .NET, responsável por gerenciar a execução de aplicativos .NET, como os escritos em C#. Ele converte o código intermediário (IL) em código de máquina específico da plataforma no momento da execução, gerencia a memória (incluindo coleta de lixo), fornece segurança e tratamento de exceções e facilita a interoperabilidade entre linguagens. Isso permite que o código seja executado em múltiplas plataformas de maneira eficiente e segura, enquanto simplifica o trabalho do desenvolvedor._______________________________________________________________________________________________________________________________________________________________________

IL (Intermediate Language), ou CIL (Common Intermediate Language), é a linguagem intermediária para a qual o código C# é compilado antes de ser executado. Esse código IL é independente de plataforma e arquitetura, permitindo que programas .NET rodem em qualquer sistema com uma implementação do CLR (Common Language Runtime).

O processo funciona assim:

Compilação para IL: O código C# é compilado para IL, não diretamente para código de máquina.
Execução com JIT: Durante a execução, o CLR usa o compilador Just-In-Time (JIT) para transformar o IL em código de máquina específico para a plataforma, garantindo desempenho e portabilidade.
Benefícios: O IL permite interoperabilidade entre linguagens, segurança e otimização de desempenho.
_______________________________________________________________________________________________________________________________________________________________________

FRAMEWORKS: É uma estrutura, um alicerce.
- Um conjunto de bibliotecas.
- Usamos como base para construir nossas aplicações.
- Para não precisar fazer tudo, começar do zero.
- Conceito existente em diversas tecnologias.
- Neste curso veremos o .NET, um framework da Microsoft.
- Ideia é trazer recursos comuns já prontos.
- Itens do dia-a-dia.
- Escrita de arquivo em disco por exemplo.
- Acesso à dados.
- Validados e testados.
- Nos poupam muito tempo.
- Não vale a pena começar sem um.
_______________________________________________________________________________________________________________________________________________________________________

- .NET FRAMEWORK:
- C# é a linguagem.
- O framework se chama .NET.
- Teve sua primeira versão em 2001.
- Chamado de .NET Framework.
- Recebeu as versões 1.0,1.1, 2.0, 3.0, 3.5, 4.x (Atualmente).
- Pode ser instalado Side-by-Side.
- Compatível somente com Windows.
Considerado legado.
_______________________________________________________________________________________________________________________________________________________________________

- .NET CORE:
- Versão moderna do .NET Framework.
- Lançado em meados de 2015.
- Veio para suportar outros SOs como Linux e Mac.
- Suas primeiras versões continham apenas o básico.
- Core significa núcleo ou seja, o essencial.
- Mudar um framework usado por milhões não é fácil.
- Foi totalmente reescrito.
- Ainda assim com ótima retro compatibilidade.
- Versão 3.1 está bem estável.
- Recomendação atual da Microsoft.
- Muitas melhorias de performance.
- Versões 1.0, 1.1, 2.0, 2.1, 3.0, 3.1.
- Instalação Side-by-Side.
_______________________________________________________________________________________________________________________________________________________________________

- .NET STANDART(é a padronização): Garante que tudo que estamos escrevendo irá rodar tanto no .NET Framework(sistema legado) quanto no .NET Core(sistema novo).

-.NET Framework e .NET CORE coexistem.
- Podem ser instalados juntos.
- Podem ser utilizados no mesmo projeto.
- Como garantir que algo que escrevemos roda em ambos?
- .NET Standart não é um framework, apenas um contrato, chamamos de Surface API.
- É a intersecção entre os frameworks.
- Garante que tudo que escrevemos será compatível com ambos os frameworks.
_______________________________________________________________________________________________________________________________________________________________________

- .NET 5 - Futuro:
- Unificação dos Frameworks.
- .NET Core chegou ao .NET Framework em nível de conteúdo.
- Não faz mais sentido ter dois frameworks.
- Atualmente em Preview.
Previsão para lançamento em Nov/2020.
_______________________________________________________________________________________________________________________________________________________________________

- RELEASE(LANÇAMENTO):
- .NET Framework: Não possuía uma data de lançamento programada.
- .NET Core: Lançamentos (Releases) semestrais.
- .NET 5 e futuros: Lançamentos anuais.
_______________________________________________________________________________________________________________________________________________________________________

-LST: Sigla para Long Term Support.
- Suporte de longa data.
- .NET Framework: Todos eram.
- .NET Core: Versões com final 1. EX: 1.1, 2.1, 3.1.
- .NET 5 e futuros: Versões maiores (Major Version).
- Opte sempre por LTS para projetos em produção.
_______________________________________________________________________________________________________________________________________________________________________

- VERSIONAMENTO DE SOFTWARE:
- Versão Semântica.
- Dividida em fases: Alpha, Beta, Release Candidate, Final.

- Dividida em três partes: Major(versão maior, mudança maior, ou produto novo), Minor(mudanças menores, que podem quebrar mas não são mudanças completas), Patch(correções de bugs).
Exemplo:  
15.8.2 - versão 15, 8 mudanças siginificativas e 2 correções de bugs. 
0.0.1  - muito inicial, não é nem uma versão oficial ainda(pode nem usar em produção ainda).
1.0.2-rc1 - versão 1, 0 mudanças, 2 cooreções de bugs e é a resease candidate(candidata a possível versão final) de número 1.

DEFINIÇÕES:
- MAJOR: Pode conter incompatibilidades com versões anteriores, chamadas de Breaking Changes.
- MINOR: Possui mudanças mas é totalmente compatível com versões anteriores,  Backward Compatility.
- PATCH: Correções de bugs e outros itens simples. 

- ALPHA: Ainda não sabe como vão ser as coisas, muito ainda pode mudar.
- Beta: Já tem ideia da estrutura, as coisas ainda podem mudar
- RELEASE CANDIDATE: Candidato a versão final.
- FINAL: Versão final.

- Podemos utilizar anotações com:
- Alpha => 0.0.1-a1.
- Beta => 0.0.2-b1.
- Release Candidate => 1.0.0-rc1.
- Final => 1.0.0
- Normalmente alpha e beta tem versões menores que 1.0.0
_______________________________________________________________________________________________________________________________________________________________________

- RUNTIME: Necessário para executar aplicações(Só roda as aplicações, executa o dll e o exe). São divididos em 3:
- ASP.NET para aplicações Web.
- DESKTOP para aplicações Desktop.
- .NET CORE para qualquer outra aplicação
- Console, Batch,  Serviço.
- Não possui uma interface por exemplo.
- Também possui versões.
- A versão tem que ser compatível com a versão utilizada durante a codificação.
- Usado somente para distribuir as aplicações.
- Apenas executa.
- Tamanho menor, otimizado para execução.
_______________________________________________________________________________________________________________________________________________________________________

- SDK: Sigla para Software Development Kit.
- Kit para desenvolvimento de software.
- Possui tudo que precisamos para criar aplicações.
- Já vem com o Runtime integrado.
- Não devemos utilizar em produção.
- Para executar precisamos apensa do Runtime.
- É maior que o Runtime.
- Já vem com tudo que precisamos.

-OBS: Runtime executa, SDK cria.
_______________________________________________________________________________________________________________________________________________________________________

- CLI: Sigla para Command Interface.
- Interface de linha de comando.
- Comandos adicionados ao nosso terminal.
- Definido pelo comando dotnet.
- dotnet --version: Verifica a versão atual.
- dotnet --list-runtimes: Lista os Runtimes instalados.
- dotnet help: Exibe a ajuda.
- Lista de comandos disponíveis.
_______________________________________________________________________________________________________________________________________________________________________

- TIPOS DE PROJETO: 
- Class Library.
- O resultado final é uma DLL.
- Não possui interface.

- Console Application.
- O resultado final é uma aplicação que roda no terminal.
- Pode receber dados, esperar input do usuário.
- Projeto Web: ASP.NET Web, ASP.NET MVC, ASP.NET WebAPI.
- Projeto Testes: Microsoft Tests.
_______________________________________________________________________________________________________________________________________________________________________

CRIANDO UM NOVO PROJETO:
-dotnet cli:

- dotnet new console  => Novo Console Application
- dotnet new classlib => Nova Class Library
- dotnet new web      => Novo projeto ASP.NET Core
- dotnet new mvc      => Novo projeto ASP.NET Core
- dotnet new webapi   => Novo projeto ASP.NET Core
- dotnet new mstest   => Novo projeto Microsoft Test.

*Criar um projeto é o mesmo que gerar os arquivos iniciais de uma aplicação.
- Vai sempre gerar os arquivos na pasta atual.
- Para especificar uma pasta, podemos utilizar o "-o"
- dotnet new console -o MeuApp.
- Vai criar uma nova pasta chamada Meu App com os arquivos dentro.

- dotnet new console --use-program-main => Cria um novo projeto C# com a estrutura clássica.
- dotnet new console --use-program-main -n MeuProjetoConsole => Cria um novo projeto C# com a estrutura clássica e permite dar um nome ao projeto. 


_______________________________________________________________________________________________________________________________________________________________________

COMANDOS TERMINAL:
- mkdir NOME_DA_PASTA: Cria uma nova pasta.
- cd .\NOME_DA_PASTA: Entra em uma pasta.
- cd .. : Volta 1 pasta.
- dir : Usado para listar arquivos em um diretório.
- cls : Usado para limpar o terminal.
_______________________________________________________________________________________________________________________________________________________________________


FLUXO DE EXECUÇÃO: 
- dotnet restore: Restaura todos os pacotes que a aplicação precisa para ser executada.(Sempre que abrirmos uma nova aplicação dotnet devemos usar esse comando para baixar todas as dependências que essa aplicação tem - pacotes adicionais que essa aplocação precisa).
- dotnet build: Compila a aplicação. (é usado para compilar o código-fonte de um projeto .NET, gerando os arquivos binários necessários para que o aplicativo seja executado).
- dotnet clean: Limpa as compilações anteriores(limpa todos os arquivos de cache da nossa aplicação).
- dotnet run: Compila e executa a aplicação.

OB: O balta sempre executa um dotnet restore, depois um dotnet clean e depois um dotnet build.
_______________________________________________________________________________________________________________________________________________________________________

* VARIÁVEIS DE AMBIENTE: É comum termos vários ambientes para nossas aplicações:
- Desenvolvimento.
- Homologação.
- Produção.

* Cada ambiente possui suas configurações:
- Chaves de acesso externo.
- Conexões com bancos de dados.

* Desta forma, podemos dizer ao .NET qual ambiente estamos utilizando:
- dotnet run --environment=$SEU_AMBIENTE
- dotnet run --environment=development
- dotnet run --environment=production

- O comando run não executa depuração (Debug).
- Neste modo sua aplicação não vai para nos Break Points.
_______________________________________________________________________________________________________________________________________________________________________

* ESTRUTURA DE UM CONSOLE APP: 
* Arquivo .csproj
- Formato XML.
- Definições do projeto.
- Presente em todo projeto .NET.

* Program.cs
- Arquivo principal (C#).
- Porta de entrada.
- Será o primeiro a ser executado.
_______________________________________________________________________________________________________________________________________________________________________

OBS:
- Não utilize espaços nem caracteres especiais na criação do programa.
- BONS: MeuApp, Pedidos, MinhaApp.
- RUINS: "Meiu App", $APP, App#Teste.

- Tente utilizar caminhos curtos e sem caracteres especiais.
- BONS: C:\apps.
- RUINS: C:\Caminho Com Espaços e Caracteres Especiais\eu App.
- Evite caminhos de rede.
- Se possível, utilize  C:\
- O C# é Case Sensitive.
- Isso significa que ele diferencia maiúsculas de minúsculas.
- Teste é diferente de teste.
_______________________________________________________________________________________________________________________________________________________________________

*ESCOPO DE UM PROGRAMA: Importações, Namespace, Classe, Método principal 
_______________________________________________________________________________________________________________________________________________________________________


* IMPORTAÇÕES (USING): 
- Importações definem as bibliotecas que nosso programa irá utilizar.
- Por padrão só o básico vem incluso.
- precisamos importar o que desejamos para poder trabalhar.
- Isto é feito no começo do programa.
- Utilizamos a palavra reservada using para isto.
- Organizar nosso código em pastas e namespaces é fundamental.
- Em aplicações grandes, o volume de código é alto.
- A quantidade de arquivos é alta.
- E o número de pessoas trabalhando no mesmo projeto também.
- Entender bem esta organização é fundamental.
- Use e abuse da criação de arquivos e namespaces.

_______________________________________________________________________________________________________________________________________________________________________

* NAMESPACE: 
- Enquanto as pastas são as divisões físicas
- Os namespaces são as divisões lógicas.
- Assim como não podemos ter dois arquivos com mesmo nome nas pastas.
- Não podemos ter duas classes com mesmo nome em um namespace.
- O ideal é ter apenas um namespace e uma classe por arquivo. 
- O escopo de um namespace é definido entre CHAVES. 
- Classes e métodos também. 
- Um namespace pode ser reutilizado.
- Pode estar presente em diversos arquivos.
-Podemos criar quantos namespaces quisermos.
- Não devem conter espaços ou caracteres especiais.
- Toda palavra no namespace começa com maiúsculo.
- Podemos ter um namespace dentro de outro usando "."
- A importação que vimos anteriormente é feita pelos namespaces.
- Normalmente acompanham os nomes das pastas.
- Durante a execução, todos os arquivos do C# serão unificados.
- A divisão física perderá.
- Sobrará apenas a divisão lógica, que são os namespaces.


-OBS: Quando você tem duas classes com o mesmo nome, mas elas estão em pastas diferentes, o problema é resolvido usando namespaces. Cada pasta pode ter seu próprio namespace, e assim as classes, mesmo com o mesmo nome, podem ser diferenciadas.
- Se desejo usar uma classe que esta em outro namespace dentro da classe principal, eu devo importar o namespace usando using na classe principal.

Exemplo Prático
Imaginemos que você tenha duas classes chamadas Program, mas elas estão em pastas diferentes dentro do seu projeto. Para evitar conflitos, você utiliza namespaces diferentes para cada pasta:

Pasta 1: MeuApp/Program.cs
O namespace desta classe será MeuApp.
Pasta 2: MeuApp/Teste/Program.cs
O namespace desta classe será MeuApp.Teste.
Mesmo que ambas as classes se chamem Program, elas têm namespaces diferentes e, por isso, são tratadas como classes distintas.

Como ficaria o código:
Classe Program na pasta MeuApp:

namespace MeuApp
{
    public class Program
    {
        public static void Main()
        {
            Console.WriteLine("Classe Program no MeuApp");
        }
    }
}


Classe Program na pasta MeuApp/Teste:


namespace MeuApp.Teste
{
    public class Program
    {
        public static void Main()
        {
            Console.WriteLine("Classe Program no MeuApp.Teste");
        }
    }
}

Como usar essas classes em outro arquivo
Agora, se você precisar usar essas classes Program em outro arquivo, você precisa especificar corretamente o namespace de cada uma delas. Por exemplo:


using MeuApp;        // Usando Program de MeuApp
using MeuApp.Teste;   // Usando Program de MeuApp.Teste

class TesteProgram
{
    static void Main()
    {
        // Instanciando a classe Program de MeuApp
        MeuApp.Program app = new MeuApp.Program();
        app.Main();

        // Instanciando a classe Program de MeuApp.Teste
        MeuApp.Teste.Program appTeste = new MeuApp.Teste.Program();
        appTeste.Main();
    }
}
O que ficou claro aqui:
Namespace é o que diferencia as classes. Mesmo que as classes tenham o mesmo nome, se elas estiverem em namespaces diferentes, elas são tratadas como entidades distintas.
MeuApp e MeuApp.Teste são namespaces diferentes, correspondendo a pastas diferentes dentro do seu projeto.
Ao referenciar as classes em outro código, você usa o namespace completo para identificar de qual classe Program você está falando.
Resumo:
Se precisar ter duas classes com o mesmo nome em pastas diferentes, você deve colocar um namespace único para cada pasta (por exemplo, MeuApp e MeuApp.Teste). Isso ajuda a evitar conflitos de nomes e mantém o código organizado.  
_______________________________________________________________________________________________________________________________________________________________________

* CLASSE:
_______________________________________________________________________________________________________________________________________________________________________

* MÉTODO PRINCIPAL:

_______________________________________________________________________________________________________________________________________________________________________

* VARIÁVEIS: 
- Uma variável é algo que utilizamos para armazenar uma informação.
- Ser variável significa que seu valor pode ser alterado a qualquer momento.
- Ou seja, ele pode variar.
- Sempre que "criamos" uma variável, dizemos que estamos inicializando ela.
- Podemos usar um TIPO ou a palavra reservada var para criar uma variável.
- Vamos aprender ainda sobre tipo de dados.
- No C# o tipo vem sempre antes do nome da variável.
- Podemos informar um valor já na criação da variável.
- Se não informado o valor padrão será aplicado.
- Utilize nomes coesos.
- Não utilize caracteres especiais ou espaços.
- Não comece com números.
- A primeira letra de cada palavra é SEMPRE minúscula.

* EXEMPLOS:
int idade; // Correto inicia com ZERO.
int idade = 25; // Correto inicia com 25.
var idade = 25; // Correto inicia com 25. Quando usamos var para declarar uma variável a variável fica como inteiro por padrão
var idade; // Errado.


_______________________________________________________________________________________________________________________________________________________________________

* CONSTANTES:
- Também utilizamos uma constante para armazenar uma informação.
- As constantes NÃO PODEM ser alteradas.
- Uma vez criadas somos obrigados a atribuir um valor.
- Feito isto elas não poderão ser modificadas novamente.
- Não funcionam com a utilização de var.
- São mais otimizadas que as variáveis.
- Recomendadas para usos frequentes.
- A definição de constante é dada pela palavra reservada const ante do tipo.
- Caso não seja informado um valor, o valor padrão será atribuído.
- Utilize nomes coesos.
- Não utilize caracteres especiais ou espaços.
- Não comece com números.
- É comum vermos constantes todas em maiúsculas, separadas por "_".
- A ideia é bater o olho no código e saber que aquilo é uma constante.

EXEMPLOS:
const int IDADE_MINIMA; // Correto inicia com ZERO
const int IDADE_MINIMA = 25; // Correto inicia com 25
const var IDADE_MINIMA = 25; // Errado (var é só para variáveis)
const var IDADE_MINIMA; // Errado (var é só para variáveis)
_______________________________________________________________________________________________________________________________________________________________________

* NOMES RESERVADOS:
- Também chamados de Keywords.
- São palavras de uso exclusivo do C#.
- Não podemos utilizar como nomes de variáveis ou constantes.
- O Visual Studio Code vai te avisar sobre eles.
_______________________________________________________________________________________________________________________________________________________________________

* COMENTÁRIOS:
- Em diversos cenários você precisará deixar uma mensagem.
- Esta mensagem não deve ser executada pelo programa.
- É comum utilizarmos comentários em linhas que não desejamos executar também.
- Podemos ter comentários de;
- Uma linha
- Múltiplas linhas
- XML (Metadata)

// Comentário em uma linha.

/*
    Comentário em várias
    linhas
*/

/// Notação XML (Metadata)	

OBS: No Vscode se você selecionar texto e apertar ctrl + k + c comenta todas as linhas e ctrl + k + u descomenta.
_______________________________________________________________________________________________________________________________________________________________________

* TIPOS PRIMITIVOS:
- Também conhecidos como built-in typoes.
- São tipos base cujo outros tipos (Complexos) irão derivar.
- Definir o tipo correto otimiza a execução do programa.
- São chamados de Tipos de Valor.
- Armazenam o valor e não a referência para um item na memória.
- São classificados em 
	- Tipos Simples(Simple Types)
	- Enumeradores(Enums)
	- Estruturas(Structs)
	- Tipos Nulos(Nullable Types)

- Cada tipo possui uma capacidade.
- Caso esta capacidade exceda, o programa gera um erro.
- Esta capacidade pré-definida ajuda na otimização do seu programa.
- Por exemplo o int que usamos previamente:
- -2,147,483,648 até 2,147,483,647
_______________________________________________________________________________________________________________________________________________________________________

* SYTEM:
- No .NET tudo começa de um tipo base chamado system.
- Todo e qualquer tio, seja built-in ou complexo deriva dele.
- Ele é a base de todos os objetos no .NET
- Não precisamos nos preocupar em usá-lo ou qualquer coisa similar
- Seu uso já é implícito.
_______________________________________________________________________________________________________________________________________________________________________

* Byte:
- O tipo byte é utilizado para representar um byte de fato.
- E diversos casos precisamos da cadeia de bytes de um arquivo por exemplo.
	- Também chamado de bytearray.
- Temos também o sbyte, que permite valores negativos.

* SIGNED e USIGNED: Valores com sinal como "-" por exemplo, são chamados de signed.

- byte (8-bit)
   - 0 até 255

- sbyte (8-bit)
   - -128 até 127

- Note que o sbyte permite valores negativos, por isto no nome sbyte, que significa Signed Byte.
_______________________________________________________________________________________________________________________________________________________________________

* Números Inteiros:
- Números inteiros, ou seja, sem pontuação, podem ser definidos pelos tipos
  - short/ushort
  - int/uint
  - long/ulong
- Assim como temos o signed nos bytes, nos números por padrão são permitidos valores negativos.
- Então usamos o unsigned para definir que o mesmo não pode receber valores negativos.
- O tipo int é o mais comum a ser encontrado.

- short (16-bit)
  - -32,768 to 32,767

- ushort (16-bit)
  - 0 até 65.535

- int (32-bit)
  - -2,147,483,648 até 2,147,483,647

- uint (32-bit)
  - 0 até 4,294, 967,295

- long (54-bit)
  - -9,223,372,036,854,775,808 até ,223,372,036,854,775,807

- ulong (64-bit)
  - 0 até 18,446,744,073,709,551,615
_______________________________________________________________________________________________________________________________________________________________________

* Números Reais:
- Números que exigem uma maior precisão, o seja com pontuação.
  - float (Notação F)
  - double
  - decimal (Notação M)

- Possuem assimilação negativa e positiva por padrão dispensando uso signed/unsigned em seus tipos.

- float (32-bit)
  - -3.402823e38 até 3.402823e38

- double (64-bit)
  - -1.79769313486232e308até 179769313486232e308

- decimal (128-bit)
  - (+ ou -)1.0 x 10e-28 até 7.9 x 10e28

*OBS: Quando usamos o var para declarar uma  variável com ponto flutuante, ela é sempre double por padrão.
_______________________________________________________________________________________________________________________________________________________________________

* BOOLEAN:
- Tipo booleano, armazena apenas true ou false (Verdadeiro ou Falso).
- Definido pela palavra reservada bool.
- bool (8-bit)
  - true ou false
_______________________________________________________________________________________________________________________________________________________________________

* CHAR:
- Utilizado para armazenar apenas um caractere no formato Unicode.
- Definido pela palavra reservada char.
- A atribuição de um valor char e dada por aspas simples.
- char (16-bit)
  - Qualquer caractere.
_______________________________________________________________________________________________________________________________________________________________________

* STRING:
- Armazena uma cadeia de caracteres.
- Podemos pensar nele como uma lista de char.
- Definido pela palavra reservada string.
- A atribuição de um valor string é dada por aspas duplas.
- string (?) 
  - Uma cadeia de caracteres
_______________________________________________________________________________________________________________________________________________________________________

* VAR:
- Substitui o nome de um tipo.
- Será do tipo do primeiro valor atribuído.
- Recomendado o uso;
  - Deixe para usar var quando já dominar os tipos.

*EXEMPLOS:
var idade = 25; // Será do tipo int.
var nome = "Lucas"; // Será do tipo string.

*OBS: Em alguns casos os var é melhor pois pode ajudar a escrever menos códigos.
_______________________________________________________________________________________________________________________________________________________________________

* OBJECT:
- Tipo genérico que recebe qualquer valor ou objeto
- Caso não possui intelisense (Ajuda dos editores) por ser um tipo desconhecido.
- Evite usar.

object idade = 25; // Será do tipo object
object nome = "Lucas"; // Será do tipo object 
_______________________________________________________________________________________________________________________________________________________________________

* NULLABLE TYPES:
* NULL:
- Significa vazio, nada.
- Diferente de zero ou uma string vazia.
- Todo tipo, primitivo o complexo pode receber o valor null.
- O tipo deve ser marcado coo Nullable Type.
- Podemos atribuir null a um objeto.
- Desde que o mesmo seja marcado como nullable.
  - Usando interrogação na frente do tipo.
- Seua chamada a um valr nulo for feita um erro será apresentado.

int? idade = null;
_______________________________________________________________________________________________________________________________________________________________________

* ALIAS:
- Alias é um apelido que todotipo no .NET tem.
- Por exemplo
  - Sytem.String tem o alias string
  - Vimos anteriormente os alias

int idade = 25; // Alias
Int32 idade = 25; // Tipo

- Como o C# é Case Sensitive, tanto faz escrevermos um ou outro.
- Porém, o recomendado é sempre usar o alias.
- No caso abaixo o resultado é o mesmo.
  - Com alias escrevemos menos. 
int idade = 25; // Alias
Int32 idade = 25; // Tipo
_______________________________________________________________________________________________________________________________________________________________________

* VALORES PADRÕES:
- Todo tipo built-in, já possui um valor padrão.
- Se nenhum valor for informado, seu valor padrão será utilizado.
  - int => 0
  - float => 0
  - decimal => 0
  - bool => false
  - char => '\0'
  - String => "" 
_______________________________________________________________________________________________________________________________________________________________________

* CONVERSÃO IMPLÍCITA:
- É comum precisarmos transformar um dado de tipo X para tipo Y.
- Existem dois tipos de conversão, as implícitas e as explícitas.
- As implícitas são conversões que
  - Podem ser executadas apenas com passagem de dados.
  - Possuem tipos compatíveis.

float valor = 25.8F;
int outro = 25;

valor = outro // Conversão implícita

- A conversão anterior ocorreu pois um número real pode receber um número inteiro.
- Porém, ao contrário não aconteceria.
  - Um número inteiro não tem pontuação.
  - Logo ele não poderia receber um número real.
- A conversão só ocorrerá se
  - O tipo de dado for compatível
  - O tamanho do dado for compatível
- Em caso de números a precisão pode ser alterada.
- Qualquer situação adversa causará erro. 

- sbyte
  - short, int, long, float, double, decimal

- byte
  - short, ushort, int, uint, long, ulong, float, double, decimal

- short
  - int, long, float, double, or decimal

- ushort
  - int, uint, long, ulong, float, double, or decimal

- int
  - long, foat, double, or decimal 

- uint
  - long, ulong, float, double, or decimal

- long
  - float, double, or decimal

- ulong
  - float, double, or decimal

- char
  - ushort, int, uint, long, ulog, float, double, or decimal

- float
  - double

*OBS: Conversão ou Cast
_______________________________________________________________________________________________________________________________________________________________________

* CONVERSAO EXPLÍCITA:
- Ocorre quando os tipos não são compatíveis.
- É dada pelo uso do tipo entre parênteses antes da atribuição.
- Segue as mesmas regras anteriores.

int inteiro = 100;
uint inteiroSemSinal = (uint)inteiro; // Conversão explícita
_______________________________________________________________________________________________________________________________________________________________________

* PARSE: Sempre espera receber uma cadeia de caracteres
- Método presente em todo tipo primitivo.
- Usado para converter um caractere ou string para um tipo qualquer
- Caso haja alguma incompatibilidade, gera um erro.

int inteiro = int.Parse("100");
_______________________________________________________________________________________________________________________________________________________________________

* CONVERT:
- Similar ao parse visto anteriormente.
- Porém permite converter vários tipos de valor.
  - Não apenas string.
- Devemos informar o tipo na chamada da conversão

int inteiro = Convert.ToInt32("100"); 
_______________________________________________________________________________________________________________________________________________________________________

* OPERAÇOES ARTMÉTICAS:
- Soma => +
- Subtração => -
- Multiplicação => *
- Divisão => /

- Multilicação e divisão são executadas primeiro
- Caso queira executar em outra ordem, usar parênteses.
- Aceita short, int, float, double e decimal. 
- Em caso de uso de números inteiros
  - Se o valor fr real, sera arredondado.
  - 4.4 => 5

int soma = 25 + 22; // 47
int subtracao = 25 - 22; // 3
int divisao = 22 / 5; // 4 - Foir arredndado 
int multiplicacao = 25 * 22; // 550

- Utilizamos parênteses para redefinir a ordem de execução.

int x = 2 + 2 * 2; // 6
int y = 2 + (2 * 2); // 6 - Mesmo do anterior
int z = (2 + 2) * 2; // 8  - Executou a soma primeiro
_______________________________________________________________________________________________________________________________________________________________________

* OPERADORES DE ATRIBUIÇÃO:
- Utilizamos igual para atribuir um valor.
- Porém, podemos utilizar igual junto a um operador aritmético.
- x += 5 é o mesmo que x = x + 5.

int x = 0;   // Atribuição
x += 5;     // x = x + 5;
x -= 1;    // x = x - 1;
x *= 10;  // x = * 10;
x /= 2;  // x = x / 2;
_______________________________________________________________________________________________________________________________________________________________________

* OPERADORES DE COMPARAÇÃO:
- Podemos comparar qualquer tipo de dado.
  - Números, strings, bytes.
- Acomparação SEMPRE retorna verdadeiro ou falso.
  - True ou False.

- Igual
  - ==

- Diferente
  - !=

- Maior que
  - >

- Menor que
  - <

- Maior ou igual a 
  - >=

- Menor ou igual a
  - <=

EXEMPLO:
int x = 25;
x == 0; // False
x != 0; // True
x > 0;  // True
x < 0;  // False
x <= 0; // False
x >= 0; // True
_______________________________________________________________________________________________________________________________________________________________________

* OPERADORES LÓGICOS:
- Usado para operações condicionais.
- Retorna SEMPRE verdadeiro ou falso.
- E-and
  - Deve atender TODAS as condições
  - &&

- OU -or
  - Se atender uma condição já retorna verdadeiro
  - ||

- NEGAÇÃO -not
  - !

EXEMPLO:
int x = 12;
bool entre = (x > 25) && (x < 40); // False
bool ou = (x > 25) || (x < 40); // True
bool negação = !(x < 25); // False
_______________________________________________________________________________________________________________________________________________________________________

* ESTRUTURAS CONDICIONAIS IF:
- Tradução: "SE" ou seja, "caso alguma condição seja atendida".
- Utilizado para tomada de decisões.
- Utiliza os operadores lógicos.
_______________________________________________________________________________________________________________________________________________________________________

* ESTRUTURAS CONDICIONAIS ELSE:
- Complemento ao if
- Caso a condição não seja atendida.
- Podemos ter
  - else if(condição)
  - Não tem limites (Mas cuidado!)
- Podemos ter apenas else para executar algo caso a condição seja atendida.

if(condição) { // Caso seja verdadeiro
       ...
}

------------------------------------------------------------------------------------

if(condição) // Caso seja verdadeiro
       ...   // Caso só haja uma linha, não precisa de chaves
------------------------------------------------------------------------------------

if(condição) { // Caso seja verdadeiro
      ...
} else { // Caso seja falso
      ...
}

------------------------------------------------------------------------------------

if(condição) // Caso seja verdadeiro
	...  // Caso haja uma linha, não pecisa de chaves
else // Caso seja falso
       ...
------------------------------------------------------------------------------------

if(condição) { // Caso seja verdaeiro
      ...
} else if(condição) { // Senão, testa outra condição
      ...
} else if(condição) { // Senão, testa outra condição
      ...
} else { // Se não acontecer nenhuma das anteriores
      ...
}
_______________________________________________________________________________________________________________________________________________________________________

* ESTRUTURAS CONDICIONAIS SWITCH:
- Utilizado quando temos muitas decisões.
- Executado em cascata.
- Devemos para manualmente a execução com o comando break;
- Possui uma execução padrão chamada default.


  






