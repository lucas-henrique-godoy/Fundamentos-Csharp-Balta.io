								CURSO DE C# BALTA.IO

O C# é uma linguagem fortemente tipada, de alto nível, compilada e gerenciada. É compilada para uma linguagem intermediária chamada IL, depois disso o gerenciador CLR runtime compila a linguagem intermediária para o código de máquina, executa e faz o gerenciamento da aplicação C#. Isso significa que não precisamos alocar memória, não precisamos nos preocupar com segurança da aplicação. É abstraído a questão de acesso a hardware.
O IL é uma linguagem intermediária em que todas as linguagens da Microsoft são compiladas.
 
O CLR (Common Language Runtime) é o ambiente de execução do .NET, responsável por gerenciar a execução de aplicativos .NET, como os escritos em C#. Ele converte o código intermediário (IL) em código de máquina específico da plataforma no momento da execução, gerencia a memória (incluindo coleta de lixo), fornece segurança e tratamento de exceções e facilita a interoperabilidade entre linguagens. Isso permite que o código seja executado em múltiplas plataformas de maneira eficiente e segura, enquanto simplifica o trabalho do desenvolvedor._______________________________________________________________________________________________________________________________________________________________________

IL (Intermediate Language), ou CIL (Common Intermediate Language), é a linguagem intermediária para a qual o código C# é compilado antes de ser executado. Esse código IL é independente de plataforma e arquitetura, permitindo que programas .NET rodem em qualquer sistema com uma implementação do CLR (Common Language Runtime).

O processo funciona assim:

Compilação para IL: O código C# é compilado para IL, não diretamente para código de máquina.
Execução com JIT: Durante a execução, o CLR usa o compilador Just-In-Time (JIT) para transformar o IL em código de máquina específico para a plataforma, garantindo desempenho e portabilidade.
Benefícios: O IL permite interoperabilidade entre linguagens, segurança e otimização de desempenho.
_______________________________________________________________________________________________________________________________________________________________________

FRAMEWORKS: É uma estrutura, um alicerce.
- Um conjunto de bibliotecas.
- Usamos como base para construir nossas aplicações.
- Para não precisar fazer tudo, começar do zero.
- Conceito existente em diversas tecnologias.
- Neste curso veremos o .NET, um framework da Microsoft.
- Ideia é trazer recursos comuns já prontos.
- Itens do dia-a-dia.
- Escrita de arquivo em disco por exemplo.
- Acesso à dados.
- Validados e testados.
- Nos poupam muito tempo.
- Não vale a pena começar sem um.
_______________________________________________________________________________________________________________________________________________________________________

- .NET FRAMEWORK:
- C# é a linguagem.
- O framework se chama .NET.
- Teve sua primeira versão em 2001.
- Chamado de .NET Framework.
- Recebeu as versões 1.0,1.1, 2.0, 3.0, 3.5, 4.x (Atualmente).
- Pode ser instalado Side-by-Side.
- Compatível somente com Windows.
Considerado legado.
_______________________________________________________________________________________________________________________________________________________________________

- .NET CORE:
- Versão moderna do .NET Framework.
- Lançado em meados de 2015.
- Veio para suportar outros SOs como Linux e Mac.
- Suas primeiras versões continham apenas o básico.
- Core significa núcleo ou seja, o essencial.
- Mudar um framework usado por milhões não é fácil.
- Foi totalmente reescrito.
- Ainda assim com ótima retro compatibilidade.
- Versão 3.1 está bem estável.
- Recomendação atual da Microsoft.
- Muitas melhorias de performance.
- Versões 1.0, 1.1, 2.0, 2.1, 3.0, 3.1.
- Instalação Side-by-Side.
_______________________________________________________________________________________________________________________________________________________________________

- .NET STANDART(é a padronização): Garante que tudo que estamos escrevendo irá rodar tanto no .NET Framework(sistema legado) quanto no .NET Core(sistema novo).

-.NET Framework e .NET CORE coexistem.
- Podem ser instalados juntos.
- Podem ser utilizados no mesmo projeto.
- Como garantir que algo que escrevemos roda em ambos?
- .NET Standart não é um framework, apenas um contrato, chamamos de Surface API.
- É a intersecção entre os frameworks.
- Garante que tudo que escrevemos será compatível com ambos os frameworks.
_______________________________________________________________________________________________________________________________________________________________________

- .NET 5 - Futuro:
- Unificação dos Frameworks.
- .NET Core chegou ao .NET Framework em nível de conteúdo.
- Não faz mais sentido ter dois frameworks.
- Atualmente em Preview.
Previsão para lançamento em Nov/2020.
_______________________________________________________________________________________________________________________________________________________________________

- RELEASE(LANÇAMENTO):
- .NET Framework: Não possuía uma data de lançamento programada.
- .NET Core: Lançamentos (Releases) semestrais.
- .NET 5 e futuros: Lançamentos anuais.
_______________________________________________________________________________________________________________________________________________________________________

-LST: Sigla para Long Term Support.
- Suporte de longa data.
- .NET Framework: Todos eram.
- .NET Core: Versões com final 1. EX: 1.1, 2.1, 3.1.
- .NET 5 e futuros: Versões maiores (Major Version).
- Opte sempre por LTS para projetos em produção.
_______________________________________________________________________________________________________________________________________________________________________

- VERSIONAMENTO DE SOFTWARE:
- Versão Semântica.
- Dividida em fases: Alpha, Beta, Release Candidate, Final.

- Dividida em três partes: Major(versão maior, mudança maior, ou produto novo), Minor(mudanças menores, que podem quebrar mas não são mudanças completas), Patch(correções de bugs).
Exemplo:  
15.8.2 - versão 15, 8 mudanças siginificativas e 2 correções de bugs. 
0.0.1  - muito inicial, não é nem uma versão oficial ainda(pode nem usar em produção ainda).
1.0.2-rc1 - versão 1, 0 mudanças, 2 cooreções de bugs e é a resease candidate(candidata a possível versão final) de número 1.

DEFINIÇÕES:
- MAJOR: Pode conter incompatibilidades com versões anteriores, chamadas de Breaking Changes.
- MINOR: Possui mudanças mas é totalmente compatível com versões anteriores,  Backward Compatility.
- PATCH: Correções de bugs e outros itens simples. 

- ALPHA: Ainda não sabe como vão ser as coisas, muito ainda pode mudar.
- Beta: Já tem ideia da estrutura, as coisas ainda podem mudar
- RELEASE CANDIDATE: Candidato a versão final.
- FINAL: Versão final.

- Podemos utilizar anotações com:
- Alpha => 0.0.1-a1.
- Beta => 0.0.2-b1.
- Release Candidate => 1.0.0-rc1.
- Final => 1.0.0
- Normalmente alpha e beta tem versões menores que 1.0.0
_______________________________________________________________________________________________________________________________________________________________________

- RUNTIME: Necessário para executar aplicações(Só roda as aplicações, executa o dll e o exe). São divididos em 3:
- ASP.NET para aplicações Web.
- DESKTOP para aplicações Desktop.
- .NET CORE para qualquer outra aplicação
- Console, Batch,  Serviço.
- Não possui uma interface por exemplo.
- Também possui versões.
- A versão tem que ser compatível com a versão utilizada durante a codificação.
- Usado somente para distribuir as aplicações.
- Apenas executa.
- Tamanho menor, otimizado para execução.
_______________________________________________________________________________________________________________________________________________________________________

- SDK: Sigla para Software Development Kit.
- Kit para desenvolvimento de software.
- Possui tudo que precisamos para criar aplicações.
- Já vem com o Runtime integrado.
- Não devemos utilizar em produção.
- Para executar precisamos apensa do Runtime.
- É maior que o Runtime.
- Já vem com tudo que precisamos.

-OBS: Runtime executa, SDK cria.
_______________________________________________________________________________________________________________________________________________________________________

- CLI: Sigla para Command Interface.
- Interface de linha de comando.
- Comandos adicionados ao nosso terminal.
- Definido pelo comando dotnet.
- dotnet --version: Verifica a versão atual.
- dotnet --list-runtimes: Lista os Runtimes instalados.
- dotnet help: Exibe a ajuda.
- Lista de comandos disponíveis.
_______________________________________________________________________________________________________________________________________________________________________

- TIPOS DE PROJETO: 
- Class Library.
- O resultado final é uma DLL.
- Não possui interface.

- Console Application.
- O resultado final é uma aplicação que roda no terminal.
- Pode receber dados, esperar input do usuário.
- Projeto Web: ASP.NET Web, ASP.NET MVC, ASP.NET WebAPI.
- Projeto Testes: Microsoft Tests.
_______________________________________________________________________________________________________________________________________________________________________

CRIANDO UM NOVO PROJETO:
-dotnet cli:

- dotnet new console  => Novo Console Application
- dotnet new classlib => Nova Class Library
- dotnet new web      => Novo projeto ASP.NET Core
- dotnet new mvc      => Novo projeto ASP.NET Core
- dotnet new webapi   => Novo projeto ASP.NET Core
- dotnet new mstest   => Novo projeto Microsoft Test.

*Criar um projeto é o mesmo que gerar os arquivos iniciais de uma aplicação.
- Vai sempre gerar os arquivos na pasta atual.
- Para especificar uma pasta, podemos utilizar o "-o"
- dotnet new console -o MeuApp.
- Vai criar uma nova pasta chamada Meu App com os arquivos dentro.

- dotnet new console --use-program-main => Cria um novo projeto C# com a estrutura clássica.
- dotnet new console --use-program-main -n MeuProjetoConsole => Cria um novo projeto C# com a estrutura clássica e permite dar um nome ao projeto. 


_______________________________________________________________________________________________________________________________________________________________________

COMANDOS TERMINAL:
- mkdir NOME_DA_PASTA: Cria uma nova pasta.
- cd .\NOME_DA_PASTA: Entra em uma pasta.
- cd .. : Volta 1 pasta.
- dir : Usado para listar arquivos em um diretório.
- cls : Usado para limpar o terminal.
_______________________________________________________________________________________________________________________________________________________________________


FLUXO DE EXECUÇÃO: 
- dotnet restore: Restaura todos os pacotes que a aplicação precisa para ser executada.(Sempre que abrirmos uma nova aplicação dotnet devemos usar esse comando para baixar todas as dependências que essa aplicação tem - pacotes adicionais que essa aplocação precisa).
- dotnet build: Compila a aplicação. (é usado para compilar o código-fonte de um projeto .NET, gerando os arquivos binários necessários para que o aplicativo seja executado).
- dotnet clean: Limpa as compilações anteriores(limpa todos os arquivos de cache da nossa aplicação).
- dotnet run: Compila e executa a aplicação.

OB: O balta sempre executa um dotnet restore, depois um dotnet clean e depois um dotnet build.
_______________________________________________________________________________________________________________________________________________________________________

* VARIÁVEIS DE AMBIENTE: É comum termos vários ambientes para nossas aplicações:
- Desenvolvimento.
- Homologação.
- Produção.

* Cada ambiente possui suas configurações:
- Chaves de acesso externo.
- Conexões com bancos de dados.

* Desta forma, podemos dizer ao .NET qual ambiente estamos utilizando:
- dotnet run --environment=$SEU_AMBIENTE
- dotnet run --environment=development
- dotnet run --environment=production

- O comando run não executa depuração (Debug).
- Neste modo sua aplicação não vai para nos Break Points.
_______________________________________________________________________________________________________________________________________________________________________

* ESTRUTURA DE UM CONSOLE APP: 
* Arquivo .csproj
- Formato XML.
- Definições do projeto.
- Presente em todo projeto .NET.

* Program.cs
- Arquivo principal (C#).
- Porta de entrada.
- Será o primeiro a ser executado.
_______________________________________________________________________________________________________________________________________________________________________

OBS:
- Não utilize espaços nem caracteres especiais na criação do programa.
- BONS: MeuApp, Pedidos, MinhaApp.
- RUINS: "Meiu App", $APP, App#Teste.

- Tente utilizar caminhos curtos e sem caracteres especiais.
- BONS: C:\apps.
- RUINS: C:\Caminho Com Espaços e Caracteres Especiais\eu App.
- Evite caminhos de rede.
- Se possível, utilize  C:\
- O C# é Case Sensitive.
- Isso significa que ele diferencia maiúsculas de minúsculas.
- Teste é diferente de teste.
_______________________________________________________________________________________________________________________________________________________________________

*ESCOPO DE UM PROGRAMA: Importações, Namespace, Classe, Método principal 
_______________________________________________________________________________________________________________________________________________________________________


* IMPORTAÇÕES (USING): 
- Importações definem as bibliotecas que nosso programa irá utilizar.
- Por padrão só o básico vem incluso.
- precisamos importar o que desejamos para poder trabalhar.
- Isto é feito no começo do programa.
- Utilizamos a palavra reservada using para isto.
- Organizar nosso código em pastas e namespaces é fundamental.
- Em aplicações grandes, o volume de código é alto.
- A quantidade de arquivos é alta.
- E o número de pessoas trabalhando no mesmo projeto também.
- Entender bem esta organização é fundamental.
- Use e abuse da criação de arquivos e namespaces.

_______________________________________________________________________________________________________________________________________________________________________

* NAMESPACE: 
- Enquanto as pastas são as divisões físicas
- Os namespaces são as divisões lógicas.
- Assim como não podemos ter dois arquivos com mesmo nome nas pastas.
- Não podemos ter duas classes com mesmo nome em um namespace.
- O ideal é ter apenas um namespace e uma classe por arquivo. 
- O escopo de um namespace é definido entre CHAVES. 
- Classes e métodos também. 
- Um namespace pode ser reutilizado.
- Pode estar presente em diversos arquivos.
-Podemos criar quantos namespaces quisermos.
- Não devem conter espaços ou caracteres especiais.
- Toda palavra no namespace começa com maiúsculo.
- Podemos ter um namespace dentro de outro usando "."
- A importação que vimos anteriormente é feita pelos namespaces.
- Normalmente acompanham os nomes das pastas.
- Durante a execução, todos os arquivos do C# serão unificados.
- A divisão física perderá.
- Sobrará apenas a divisão lógica, que são os namespaces.


-OBS: Quando você tem duas classes com o mesmo nome, mas elas estão em pastas diferentes, o problema é resolvido usando namespaces. Cada pasta pode ter seu próprio namespace, e assim as classes, mesmo com o mesmo nome, podem ser diferenciadas.
- Se desejo usar uma classe que esta em outro namespace dentro da classe principal, eu devo importar o namespace usando using na classe principal.

Exemplo Prático
Imaginemos que você tenha duas classes chamadas Program, mas elas estão em pastas diferentes dentro do seu projeto. Para evitar conflitos, você utiliza namespaces diferentes para cada pasta:

Pasta 1: MeuApp/Program.cs
O namespace desta classe será MeuApp.
Pasta 2: MeuApp/Teste/Program.cs
O namespace desta classe será MeuApp.Teste.
Mesmo que ambas as classes se chamem Program, elas têm namespaces diferentes e, por isso, são tratadas como classes distintas.

Como ficaria o código:
Classe Program na pasta MeuApp:

namespace MeuApp
{
    public class Program
    {
        public static void Main()
        {
            Console.WriteLine("Classe Program no MeuApp");
        }
    }
}


Classe Program na pasta MeuApp/Teste:


namespace MeuApp.Teste
{
    public class Program
    {
        public static void Main()
        {
            Console.WriteLine("Classe Program no MeuApp.Teste");
        }
    }
}

Como usar essas classes em outro arquivo
Agora, se você precisar usar essas classes Program em outro arquivo, você precisa especificar corretamente o namespace de cada uma delas. Por exemplo:


using MeuApp;        // Usando Program de MeuApp
using MeuApp.Teste;   // Usando Program de MeuApp.Teste

class TesteProgram
{
    static void Main()
    {
        // Instanciando a classe Program de MeuApp
        MeuApp.Program app = new MeuApp.Program();
        app.Main();

        // Instanciando a classe Program de MeuApp.Teste
        MeuApp.Teste.Program appTeste = new MeuApp.Teste.Program();
        appTeste.Main();
    }
}
O que ficou claro aqui:
Namespace é o que diferencia as classes. Mesmo que as classes tenham o mesmo nome, se elas estiverem em namespaces diferentes, elas são tratadas como entidades distintas.
MeuApp e MeuApp.Teste são namespaces diferentes, correspondendo a pastas diferentes dentro do seu projeto.
Ao referenciar as classes em outro código, você usa o namespace completo para identificar de qual classe Program você está falando.
Resumo:
Se precisar ter duas classes com o mesmo nome em pastas diferentes, você deve colocar um namespace único para cada pasta (por exemplo, MeuApp e MeuApp.Teste). Isso ajuda a evitar conflitos de nomes e mantém o código organizado.  
_______________________________________________________________________________________________________________________________________________________________________

* CLASSE:
_______________________________________________________________________________________________________________________________________________________________________

* MÉTODO PRINCIPAL:

_______________________________________________________________________________________________________________________________________________________________________

* VARIÁVEIS: 
- Uma variável é algo que utilizamos para armazenar uma informação.
- Ser variável significa que seu valor pode ser alterado a qualquer momento.
- Ou seja, ele pode variar.
- Sempre que "criamos" uma variável, dizemos que estamos inicializando ela.
- Podemos usar um TIPO ou a palavra reservada var para criar uma variável.
- Vamos aprender ainda sobre tipo de dados.
- No C# o tipo vem sempre antes do nome da variável.
- Podemos informar um valor já na criação da variável.
- Se não informado o valor padrão será aplicado.
- Utilize nomes coesos.
- Não utilize caracteres especiais ou espaços.
- Não comece com números.
- A primeira letra de cada palavra é SEMPRE minúscula.

* EXEMPLOS:
int idade; // Correto inicia com ZERO.
int idade = 25; // Correto inicia com 25.
var idade = 25; // Correto inicia com 25. Quando usamos var para declarar uma variável a variável fica como inteiro por padrão
var idade; // Errado.


_______________________________________________________________________________________________________________________________________________________________________

* CONSTANTES:
- Também utilizamos uma constante para armazenar uma informação.
- As constantes NÃO PODEM ser alteradas.
- Uma vez criadas somos obrigados a atribuir um valor.
- Feito isto elas não poderão ser modificadas novamente.
- Não funcionam com a utilização de var.
- São mais otimizadas que as variáveis.
- Recomendadas para usos frequentes.
- A definição de constante é dada pela palavra reservada const ante do tipo.
- Caso não seja informado um valor, o valor padrão será atribuído.
- Utilize nomes coesos.
- Não utilize caracteres especiais ou espaços.
- Não comece com números.
- É comum vermos constantes todas em maiúsculas, separadas por "_".
- A ideia é bater o olho no código e saber que aquilo é uma constante.

EXEMPLOS:
const int IDADE_MINIMA; // Correto inicia com ZERO
const int IDADE_MINIMA = 25; // Correto inicia com 25
const var IDADE_MINIMA = 25; // Errado (var é só para variáveis)
const var IDADE_MINIMA; // Errado (var é só para variáveis)
_______________________________________________________________________________________________________________________________________________________________________

* NOMES RESERVADOS:
- Também chamados de Keywords.
- São palavras de uso exclusivo do C#.
- Não podemos utilizar como nomes de variáveis ou constantes.
- O Visual Studio Code vai te avisar sobre eles.
_______________________________________________________________________________________________________________________________________________________________________

* COMENTÁRIOS:
- Em diversos cenários você precisará deixar uma mensagem.
- Esta mensagem não deve ser executada pelo programa.
- É comum utilizarmos comentários em linhas que não desejamos executar também.
- Podemos ter comentários de;
- Uma linha
- Múltiplas linhas
- XML (Metadata)

// Comentário em uma linha.

/*
    Comentário em várias
    linhas
*/

/// Notação XML (Metadata)	

OBS: No Vscode se você selecionar texto e apertar ctrl + k + c comenta todas as linhas e ctrl + k + u descomenta.
_______________________________________________________________________________________________________________________________________________________________________

* TIPOS PRIMITIVOS:
- Também conhecidos como built-in typoes.
- São tipos base cujo outros tipos (Complexos) irão derivar.
- Definir o tipo correto otimiza a execução do programa.
- São chamados de Tipos de Valor.
- Armazenam o valor e não a referência para um item na memória.
- São classificados em 
	- Tipos Simples(Simple Types)
	- Enumeradores(Enums)
	- Estruturas(Structs)
	- Tipos Nulos(Nullable Types)

- Cada tipo possui uma capacidade.
- Caso esta capacidade exceda, o programa gera um erro.
- Esta capacidade pré-definida ajuda na otimização do seu programa.
- Por exemplo o int que usamos previamente:
- -2,147,483,648 até 2,147,483,647
_______________________________________________________________________________________________________________________________________________________________________

* SYTEM:
- No .NET tudo começa de um tipo base chamado system.
- Todo e qualquer tio, seja built-in ou complexo deriva dele.
- Ele é a base de todos os objetos no .NET
- Não precisamos nos preocupar em usá-lo ou qualquer coisa similar
- Seu uso já é implícito.
_______________________________________________________________________________________________________________________________________________________________________

* Byte:
- O tipo byte é utilizado para representar um byte de fato.
- E diversos casos precisamos da cadeia de bytes de um arquivo por exemplo.
	- Também chamado de bytearray.
- Temos também o sbyte, que permite valores negativos.

* SIGNED e USIGNED: Valores com sinal como "-" por exemplo, são chamados de signed.

- byte (8-bit)
   - 0 até 255

- sbyte (8-bit)
   - -128 até 127

- Note que o sbyte permite valores negativos, por isto no nome sbyte, que significa Signed Byte.
_______________________________________________________________________________________________________________________________________________________________________

* Números Inteiros:
- Números inteiros, ou seja, sem pontuação, podem ser definidos pelos tipos
  - short/ushort
  - int/uint
  - long/ulong
- Assim como temos o signed nos bytes, nos números por padrão são permitidos valores negativos.
- Então usamos o unsigned para definir que o mesmo não pode receber valores negativos.
- O tipo int é o mais comum a ser encontrado.

- short (16-bit)
  - -32,768 to 32,767

- ushort (16-bit)
  - 0 até 65.535

- int (32-bit)
  - -2,147,483,648 até 2,147,483,647

- uint (32-bit)
  - 0 até 4,294, 967,295

- long (54-bit)
  - -9,223,372,036,854,775,808 até ,223,372,036,854,775,807

- ulong (64-bit)
  - 0 até 18,446,744,073,709,551,615
_______________________________________________________________________________________________________________________________________________________________________

* Números Reais:
- Números que exigem uma maior precisão, o seja com pontuação.
  - float (Notação F)
  - double
  - decimal (Notação M)

- Possuem assimilação negativa e positiva por padrão dispensando uso signed/unsigned em seus tipos.

- float (32-bit)
  - -3.402823e38 até 3.402823e38

- double (64-bit)
  - -1.79769313486232e308até 179769313486232e308

- decimal (128-bit)
  - (+ ou -)1.0 x 10e-28 até 7.9 x 10e28

*OBS: Quando usamos o var para declarar uma  variável com ponto flutuante, ela é sempre double por padrão.
_______________________________________________________________________________________________________________________________________________________________________

* BOOLEAN:
- Tipo booleano, armazena apenas true ou false (Verdadeiro ou Falso).
- Definido pela palavra reservada bool.
- bool (8-bit)
  - true ou false
_______________________________________________________________________________________________________________________________________________________________________

* CHAR:
- Utilizado para armazenar apenas um caractere no formato Unicode.
- Definido pela palavra reservada char.
- A atribuição de um valor char e dada por aspas simples.
- char (16-bit)
  - Qualquer caractere.
_______________________________________________________________________________________________________________________________________________________________________

* STRING:
- Armazena uma cadeia de caracteres.
- Podemos pensar nele como uma lista de char.
- Definido pela palavra reservada string.
- A atribuição de um valor string é dada por aspas duplas.
- string (?) 
  - Uma cadeia de caracteres
_______________________________________________________________________________________________________________________________________________________________________

* VAR:
- Substitui o nome de um tipo.
- Será do tipo do primeiro valor atribuído.
- Recomendado o uso;
  - Deixe para usar var quando já dominar os tipos.

*EXEMPLOS:
var idade = 25; // Será do tipo int.
var nome = "Lucas"; // Será do tipo string.

*OBS: Em alguns casos os var é melhor pois pode ajudar a escrever menos códigos.
_______________________________________________________________________________________________________________________________________________________________________

* OBJECT:
- Tipo genérico que recebe qualquer valor ou objeto
- Caso não possui intelisense (Ajuda dos editores) por ser um tipo desconhecido.
- Evite usar.

object idade = 25; // Será do tipo object
object nome = "Lucas"; // Será do tipo object 
_______________________________________________________________________________________________________________________________________________________________________

* NULLABLE TYPES:
* NULL:
- Significa vazio, nada.
- Diferente de zero ou uma string vazia.
- Todo tipo, primitivo o complexo pode receber o valor null.
- O tipo deve ser marcado coo Nullable Type.
- Podemos atribuir null a um objeto.
- Desde que o mesmo seja marcado como nullable.
  - Usando interrogação na frente do tipo.
- Seua chamada a um valr nulo for feita um erro será apresentado.

int? idade = null;
_______________________________________________________________________________________________________________________________________________________________________

* ALIAS:
- Alias é um apelido que todotipo no .NET tem.
- Por exemplo
  - Sytem.String tem o alias string
  - Vimos anteriormente os alias

int idade = 25; // Alias
Int32 idade = 25; // Tipo

- Como o C# é Case Sensitive, tanto faz escrevermos um ou outro.
- Porém, o recomendado é sempre usar o alias.
- No caso abaixo o resultado é o mesmo.
  - Com alias escrevemos menos. 
int idade = 25; // Alias
Int32 idade = 25; // Tipo
_______________________________________________________________________________________________________________________________________________________________________

* VALORES PADRÕES:
- Todo tipo built-in, já possui um valor padrão.
- Se nenhum valor for informado, seu valor padrão será utilizado.
  - int => 0
  - float => 0
  - decimal => 0
  - bool => false
  - char => '\0'
  - String => "" 
_______________________________________________________________________________________________________________________________________________________________________

* CONVERSÃO IMPLÍCITA:
- É comum precisarmos transformar um dado de tipo X para tipo Y.
- Existem dois tipos de conversão, as implícitas e as explícitas.
- As implícitas são conversões que
  - Podem ser executadas apenas com passagem de dados.
  - Possuem tipos compatíveis.

float valor = 25.8F;
int outro = 25;

valor = outro // Conversão implícita

- A conversão anterior ocorreu pois um número real pode receber um número inteiro.
- Porém, ao contrário não aconteceria.
  - Um número inteiro não tem pontuação.
  - Logo ele não poderia receber um número real.
- A conversão só ocorrerá se
  - O tipo de dado for compatível
  - O tamanho do dado for compatível
- Em caso de números a precisão pode ser alterada.
- Qualquer situação adversa causará erro. 

- sbyte
  - short, int, long, float, double, decimal

- byte
  - short, ushort, int, uint, long, ulong, float, double, decimal

- short
  - int, long, float, double, or decimal

- ushort
  - int, uint, long, ulong, float, double, or decimal

- int
  - long, foat, double, or decimal 

- uint
  - long, ulong, float, double, or decimal

- long
  - float, double, or decimal

- ulong
  - float, double, or decimal

- char
  - ushort, int, uint, long, ulog, float, double, or decimal

- float
  - double

*OBS: Conversão ou Cast
_______________________________________________________________________________________________________________________________________________________________________

* CONVERSAO EXPLÍCITA:
- Ocorre quando os tipos não são compatíveis.
- É dada pelo uso do tipo entre parênteses antes da atribuição.
- Segue as mesmas regras anteriores.

int inteiro = 100;
uint inteiroSemSinal = (uint)inteiro; // Conversão explícita
_______________________________________________________________________________________________________________________________________________________________________

* PARSE: Sempre espera receber uma cadeia de caracteres
- Método presente em todo tipo primitivo.
- Usado para converter um caractere ou string para um tipo qualquer
- Caso haja alguma incompatibilidade, gera um erro.

int inteiro = int.Parse("100");
_______________________________________________________________________________________________________________________________________________________________________

* CONVERT:
- Similar ao parse visto anteriormente.
- Porém permite converter vários tipos de valor.
  - Não apenas string.
- Devemos informar o tipo na chamada da conversão

int inteiro = Convert.ToInt32("100"); 
_______________________________________________________________________________________________________________________________________________________________________

* OPERAÇOES ARTMÉTICAS:
- Soma => +
- Subtração => -
- Multiplicação => *
- Divisão => /

- Multilicação e divisão são executadas primeiro
- Caso queira executar em outra ordem, usar parênteses.
- Aceita short, int, float, double e decimal. 
- Em caso de uso de números inteiros
  - Se o valor fr real, sera arredondado.
  - 4.4 => 5

int soma = 25 + 22; // 47
int subtracao = 25 - 22; // 3
int divisao = 22 / 5; // 4 - Foir arredndado 
int multiplicacao = 25 * 22; // 550

- Utilizamos parênteses para redefinir a ordem de execução.

int x = 2 + 2 * 2; // 6
int y = 2 + (2 * 2); // 6 - Mesmo do anterior
int z = (2 + 2) * 2; // 8  - Executou a soma primeiro
_______________________________________________________________________________________________________________________________________________________________________

* OPERADORES DE ATRIBUIÇÃO:
- Utilizamos igual para atribuir um valor.
- Porém, podemos utilizar igual junto a um operador aritmético.
- x += 5 é o mesmo que x = x + 5.

int x = 0;   // Atribuição
x += 5;     // x = x + 5;
x -= 1;    // x = x - 1;
x *= 10;  // x = * 10;
x /= 2;  // x = x / 2;
_______________________________________________________________________________________________________________________________________________________________________

* OPERADORES DE COMPARAÇÃO:
- Podemos comparar qualquer tipo de dado.
  - Números, strings, bytes.
- Acomparação SEMPRE retorna verdadeiro ou falso.
  - True ou False.

- Igual
  - ==

- Diferente
  - !=

- Maior que
  - >

- Menor que
  - <

- Maior ou igual a 
  - >=

- Menor ou igual a
  - <=

EXEMPLO:
int x = 25;
x == 0; // False
x != 0; // True
x > 0;  // True
x < 0;  // False
x <= 0; // False
x >= 0; // True
_______________________________________________________________________________________________________________________________________________________________________

* OPERADORES LÓGICOS:
- Usado para operações condicionais.
- Retorna SEMPRE verdadeiro ou falso.
- E-and
  - Deve atender TODAS as condições
  - &&

- OU -or
  - Se atender uma condição já retorna verdadeiro
  - ||

- NEGAÇÃO -not
  - !

EXEMPLO:
int x = 12;
bool entre = (x > 25) && (x < 40); // False
bool ou = (x > 25) || (x < 40); // True
bool negação = !(x < 25); // False
_______________________________________________________________________________________________________________________________________________________________________

* ESTRUTURAS CONDICIONAIS IF:
- Tradução: "SE" ou seja, "caso alguma condição seja atendida".
- Utilizado para tomada de decisões.
- Utiliza os operadores lógicos.
_______________________________________________________________________________________________________________________________________________________________________

* ESTRUTURAS CONDICIONAIS ELSE:
- Complemento ao if
- Caso a condição não seja atendida.
- Podemos ter
  - else if(condição)
  - Não tem limites (Mas cuidado!)
- Podemos ter apenas else para executar algo caso a condição seja atendida.

if(condição) { // Caso seja verdadeiro
       ...
}

------------------------------------------------------------------------------------

if(condição) // Caso seja verdadeiro
       ...   // Caso só haja uma linha, não precisa de chaves
------------------------------------------------------------------------------------

if(condição) { // Caso seja verdadeiro
      ...
} else { // Caso seja falso
      ...
}

------------------------------------------------------------------------------------

if(condição) // Caso seja verdadeiro
	...  // Caso haja uma linha, não pecisa de chaves
else // Caso seja falso
       ...
------------------------------------------------------------------------------------

if(condição) { // Caso seja verdaeiro
      ...
} else if(condição) { // Senão, testa outra condição
      ...
} else if(condição) { // Senão, testa outra condição
      ...
} else { // Se não acontecer nenhuma das anteriores
      ...
}
_______________________________________________________________________________________________________________________________________________________________________

* ESTRUTURAS CONDICIONAIS SWITCH:
- Utilizado quando temos muitas decisões.
- Executado em cascata.
- Devemos para manualmente a execução com o comando break;
- Possui uma execução padrão chamada default.

int valor = 1;
switch (valor)
{
    case 1: Console.WriteLine("1"); break;
    case 2: Console.WriteLine("2"); break;
    case 3: Console.WriteLine("3"); break;
    default: Console.WriteLine("4"); break; // Se não for 1,2 ou 3
}
_______________________________________________________________________________________________________________________________________________________________________

* LAÇO DE REPEETIÇÃO: FOR
- Tradução "para", ou seja, para cada item em um valor...
- Executa uma determinada ação várias vezes.
- Definido pela palavra for
- Exige 3 parâmetros.
  - Contador
  - Condição
  - Incremento.

- for (var i = 0; i <= 5; i++)
------------------------------------------------------------------------------------
EXEMPLOS:
// Conta de 0 a 5
for (var i = 0; i <= 5; i++)
    Console.WritLine(i);
------------------------------------------------------------------------------------
// Conta de 1 a 5
for (var i = 1; i <= 5; i++)
    Console.WritLine(i);
------------------------------------------------------------------------------------
// Conta de 0 a 4
for (var i = 0; i < 5; i++)
    Console.WritLine(i);
------------------------------------------------------------------------------------
// Conta de 5 a 0
for (var i = 5; i >= 0; i--)
    Console.WritLine(i);
_______________________________________________________________________________________________________________________________________________________________________

* LAÇOS DE REPETIÇÃO: WHILE
- Tradução: "Enquanto", ou seja, enquanto uma condição for verdadeira...
- Definido pela palavra while.
- Exige apenas uma condição.
- Checa a condição ANTES de executar.
------------------------------------------------------------------------------------
EXEMPLO 1:
var valor = 0;
// Conta de 0 a 5
// Exibe de 0 a 5 na tela
while (valor <= 5)
{
   Console.WriteLine(valor);
   valor++;
}
------------------------------------------------------------------------------------
EXEMPLO 2:
valor = 0;
// Conta de 0 a 5
// Exibe de 1 a 6 na tela
while (valor <= 5)
{
  valor++;
  Console.WriteLine(valor);
}
------------------------------------------------------------------------------------
EXEMPLO 3:
valor = 0;
// Infinito
while (true)
{
  valor++;
  Console.WriteLine(valor);
}
_______________________________________________________________________________________________________________________________________________________________________

* LAÇOS DE REPETIÇÃO: DO
- Tradução: "Faça", ou seja,  realiza uma ação enquanto...
- Definido pela palavra do/while
- Exige apenas uma condição no while
- Checa a condição DEPOIS de executar

var valor = 0;
do 
{
    Console.WriteLine("Teste");
    valor++;
} while (valor < 5);
_______________________________________________________________________________________________________________________________________________________________________

* FUNÇÕES ou MÉTODOS:
- Podemos segmentar nosso programa em funções.
- Também conhecidos como métodos.
- O main é um exemplo de método.
- Possui um retorno, um nome e parâmetros.
- Esta composição é camada de assinatura.
- Começam sempre com maiúscula.

static void Main(string[] args)
{
     // Invocação do método
     MeuMetodo("C# é legal!");
}


// Definição do método
static void MeuMetodo(string parametro)
{
   Console.WriteLine(parametro);
}
------------------------------------------------------------------------------------

// Definição do método
// Retorna uma string e recebe vários parâmetros

static string RetornaNome(string nome, string sobrenome)
{
     // Retorna o nome e sobrenome
     return nome + "" + sobrenome;
}



static void Main(string[] args)
{
    // Invocação do método
   // Armazena o resultado em uma variável
   var nome = RetornaNome("Lucas", "Henrique");

   // Imprime o nome na tela
   Console.WriteLine(nome);
}

_______________________________________________________________________________________________________________________________________________________________________

* PARÂMETROS QUANDO DEVO OU NÃO USAR?:

A decisão de usar ou não parâmetros em um método depende do comportamento e da lógica que você deseja implementar no método. Em termos gerais, você deve usar parâmetros quando o método precisar de informações externas para realizar suas tarefas. Se o método não precisar de dados externos e seu comportamento for independente, então você pode criar o método sem parâmetros.

Aqui estão algumas diretrizes para entender quando usar ou não parâmetros em um método:

1. Quando usar parâmetros:
Você deve usar parâmetros quando o comportamento do método depender de valores que não são conhecidos dentro do próprio método, ou seja, quando você precisar passar informações de fora do método para ele.

Exemplos de situações onde é necessário usar parâmetros:

Operações que dependem de entradas específicas: Se o método precisa de dados fornecidos pelo usuário ou por outro código para executar sua lógica, você usará parâmetros. Por exemplo, um método para somar dois números precisa dos números a serem somados.

java
Copiar código
public int somar(int a, int b) {
    return a + b;
}
Métodos reutilizáveis e genéricos: Se você quiser que um método seja flexível e reutilizável em várias partes do código com diferentes valores de entrada, você usará parâmetros. Por exemplo, um método que calcula o imposto de um valor qualquer pode usar um parâmetro para representar o valor a ser tributado.

java
Copiar código
public double calcularImposto(double valor) {
    return valor * 0.2;  // 20% de imposto
}
Métodos que modificam dados passados: Se o método precisa modificar dados que são passados para ele (como variáveis ou objetos), ele precisará de parâmetros.

java
Copiar código
public void incrementarValor(int[] numeros) {
    for (int i = 0; i < numeros.length; i++) {
        numeros[i] += 1;
    }
}
2. Quando NÃO usar parâmetros:
Você pode criar métodos sem parâmetros quando a lógica do método não depende de dados externos ou quando ele lida apenas com valores internos, conhecidos dentro do próprio método.

Exemplos de situações em que não são necessários parâmetros:

Métodos que realizam operações internas e não dependem de entradas externas: Se o método realiza uma operação simples que não necessita de dados externos, você pode omitir os parâmetros. Por exemplo, um método que retorna uma constante ou realiza uma operação interna sem necessidade de dados externos.

java
Copiar código
public int obterNumeroMagico() {
    return 42;  // Retorna sempre o mesmo número
}
Métodos que utilizam variáveis internas ou de instância: Se o método faz uso de variáveis de instância (atributos da classe) ou variáveis locais dentro do próprio método, você pode não precisar de parâmetros.

java
Copiar código
public int calcularSoma() {
    int a = 10;
    int b = 5;
    return a + b;
}
Métodos que alteram o estado do objeto ou fazem tarefas sem necessidade de entradas externas: Em certos casos, o método pode atuar diretamente sobre o estado de um objeto ou realizar ações sem precisar de dados externos. Por exemplo, um método que apenas altera um atributo de uma classe.

java
Copiar código
public void resetarContador() {
    contador = 0;
}
Resumo:
Use parâmetros quando o método precisar de dados externos (entradas) para realizar uma tarefa.
Não use parâmetros quando o método não depender de dados externos e realizar tarefas com informações internas ou constantes.
Exemplos práticos:
Método com parâmetros:

Se você estiver escrevendo um método para calcular o preço total de um pedido, ele precisará de parâmetros como a quantidade de itens e o preço unitário.
java
Copiar código
public double calcularPrecoTotal(int quantidade, double precoUnitario) {
    return quantidade * precoUnitario;
}
Método sem parâmetros:

Se você tiver um método que apenas retorna um valor fixo ou manipula dados internos, você não precisará de parâmetros.
java
Copiar código
public String obterStatus() {
    return "Em andamento";
}
Ao projetar seus métodos, sempre pergunte-se: "Este método precisa de informações externas para fazer seu trabalho?" Se a resposta for sim, use parâmetros. Se não, você pode deixá-los de fora.

* OBS: Parâmetros opcionais devem ter o sinal de igual e devem vir Por ultimo nu método. Se na chamado do método for passado um outro valor ao invés do opcional, esse valor é o que será exibido.
EXEMPLO:

static string RetornaNome(string nome, string sobrenome, int idade = 27)// idade como parâmetro opcional
        {
            return nome + " " + sobrenome + " tem " + idade.ToString();
        }
 
_______________________________________________________________________________________________________________________________________________________________________

* TIPOS DE REFERÊNCIA E TIPOS DE VALOR:
* HEAP e STACK.
- A memória é dividida em duas partes, Heap e Stack.
- Heap armazena os dados.
- Stack armazena as referências(endereço de onde está a informação) para os dados.

- Qualquer tipo no .NET é tratado como
  - Tipo de Referência (Reference Type).
  - Tipo de Valor (Value Type).
- Tipos de valor armazenam dados.
- São armazenados em um local da memória chamada Stack.
------------------------------------------------------------------------------------
* VALUE TYPES:
- Quando armazenamos um valor, a memória é alocada.
- Este espaço armazena o dado criado.
- Nossa variável acessa este dado diretamente.
- Se assimilarmos uma variável do tipo de valor a outra
  - O valor será COPIADO.
  - Ambas serão independentes.
- Built-in, Structs, Enums.
- Garbage Collector(Coletor de lixos) não acessa o Stack.

EX:
int x = 25;
int y = x; // y é uma cópia de x.
Console.WriteLine(x); // 25
Console.WriteLine(y); //25
x = 32; // Somente x foi alterado
Console.WriteLine(x); // 32
Console.WriteLine(y); // 32
------------------------------------------------------------------------------------

* REFERENCE TYPES:
- Armazenam o endereço do objeto que contém os dados.
- Não armazena os dados em si.
- São armazenados em um local da memória chamado de Heap.
- Ao assimilar uma variável.
  - Criará uma referência.
  - Aponta para a mesma informação.
  - Não são independentes.
- Quando não mais utilizados são marcados para exclusão.
- Garbage Collector passa removendo todos eles.
- Classes, Objects, Arrays...

EX:
var arr = new string[2];
arr[0] = "Item 1";
var arr = arr; // Não cria uma cópia

Console.WriteLine(arr[0]);
Console.WriteLine(arr2[0]);

// Altera as duas listas
arr[0] = "Item Alterado";
Console.WriteLine(arr[0]);
Console.WriteLine(arr2[0]);
_______________________________________________________________________________________________________________________________________________________________________

* STRUCTS: Devem ser criados forra do Main e fora da classe.
- Tipos de do estruturado.
- Apenas a estrutura, o esqueleto.
- Tipo de valor.
- Armazenam apenas outros tipos de dados.
- Definido pela palavra struct.
- Composto de propriedades e métodos.
- Nome sempre com maiúsculo.
  - O mesmo para propriedades e métodos.
- Criado a partir da palavra new.
  - Neste momento sim temos os valores.
- A anatomia de uma estrutura normalmente é:

* SINTAXE:
struct Product
{
    // Propriedades

    // Métodos
}

------------------------------------------------------------------------------------
* A anatomia de uma propriedade:

struct Product
{
    // Propriedades
    public int Id;

    // Métodos
}
------------------------------------------------------------------------------------

* A anatomia de um método:

struct Product
{
    public int Id;
    public float Price;

    public float PriceInDolar(float dolar)
    {
      return Price * dolar;
    }

}
------------------------------------------------------------------------------------

* Para criar uma estrutura:

static void Main(string[] args)
{
   // Cria uma estrutura
   var product = new Product();
}
------------------------------------------------------------------------------------

- Vem com dados dos tipos padrão.
- Para preencher os dados.

* OUTRO EXEMPLO:
var product = new Product();
product.Id = 1;
product.Tittle = "Mouse gamer";
product.Price = 197.23f;
Console.WriteLine(product.Id);
Console.WriteLine(product.Tittle);
Console.WriteLine(product.Price);
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

* OBS: Sempre que encontrarmos um método com o mesmo nome da classe ou estrutura e que não tem retorno, esse é um método construtor. Ele sempre é executado quando a struct é criada, ou seja, toda vez que você as um new para criar uma nova struct ele irá passar por esse método construtor, esse método vai sempre ser chamado. Então se precisarmos inicializar algum valor, esse é o local correto.

- Método construtor é um método com mesmo nome da struct.
struct Product
{
  public Product(int id, string tittle, float price)
  {
     Id = id;
     Tittle = tittle;
     Price = price;
  } 
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

- Eles facilitam a criação de estruturas
var product = new Produto(1, "Mouse Gamer", 128.75f);
Console.WriteLine(product.Id);
Console.WriteLine(product.Tittle);
Console.WriteLine(product.Price);
Console.WriteLine(product.PriceInDolar(5.70f));
_______________________________________________________________________________________________________________________________________________________________________

* ENUMS (ENUMERADORES): É UM INTEIRO QUE:
- Usado para fornecer uma melhor visualização do código.
- Substituem o uso de inteiros.
- Usados em listas curtas.
- Usados em dados fixos.
  - Hard Coded.
- Sempre maiúsculo.
  - Começar com a letra E.

* ANATOMIA DE UM ENUMERADOR:
enum EEstadoCivil
{
     // Enumeradores 
}
----------------------------------------------------------------------

enum EEstadoCivil
{
   Solteiro = 1;
   Casado = 2;
   Divorciado = 3;
}

----------------------------------------------------------------------

* USO DE UM ENUMERADOR:
struct Cliente 
{
    public string Nome;
    public EEstadoCivil EstadoCivil;
}


// Sem enumeradores
// var = new Cliente("João Silva", 1);

// Com enumerador
var cliente = new Cliente("João Silva, EEstadoCivil.Casado");
----------------------------------------------------------------------

* EXIBINDO DADOS DE UM ENUMERADOR:
Console.WriteLine(cliente.Nome);
Console.WriteLine(cliente.EstadoCivil); // Escreve casado
Console.WriteLine((int)cliente.EstadoCivil); // Escreve 2

_______________________________________________________________________________________________________________________________________________________________________

USING - USOS:

Em C#, a palavra-chave using é usada para:

1- IMPORTAR NAMESPACES:

Permite acessar classes de um namespace sem precisar escrever o caminho completo.
using System;
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

2- GERENCIAR RECURSOS (IDisposable):

É utilizada para garantir que objetos que gerenciam recursos, como conexões de banco de dados ou arquivos, sejam descartados corretamente após o uso, chamando automaticamente o método Dispose().
Exemplo com banco de dados:

using (SqlConnection connection = new SqlConnection(connectionString))
{
    connection.Open();
    // Executar comandos SQL aqui
}

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
3- USO COM BANCO DE DADOS:

Conexão (SqlConnection): Garante que a conexão com o banco de dados seja fechada automaticamente.
Comando (SqlCommand) e Leitura (SqlDataReader): São usados dentro de blocos using para garantir a liberação dos recursos após o uso.
Exemplo:
csharp
Copiar código
using (SqlConnection connection = new SqlConnection(connectionString))
{
    connection.Open();
    using (SqlCommand command = new SqlCommand("SELECT * FROM Tabela", connection))
    using (SqlDataReader reader = command.ExecuteReader())
    {
        // Processar dados
    }
}

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
4- TRANSAÇÕES COM BANCO DE DADOS:

Usado para garantir que múltiplas operações sejam executadas como uma única unidade, com a possibilidade de confirmar (Commit) ou desfazer (Rollback) mudanças.
Exemplo com transação:

using (SqlConnection connection = new SqlConnection(connectionString))
{
    connection.Open();
    using (SqlTransaction transaction = connection.BeginTransaction())
    {
        // Executar comandos dentro da transação
        transaction.Commit();  // ou transaction.Rollback();
    }
}
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

* RESUMO: O using é usado principalmente para garantir o correto gerenciamento de recursos (como conexões com bancos de dados) e para facilitar o código com a importação de namespaces. Ele automaticamente libera recursos ao final do bloco de código, evitando vazamentos e simplificando a manutenção do código.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

Você disse:
é usado para abrir e fechar coisas ?

O ChatGPT disse:
ChatGPT
Sim, o using em C# é frequentemente utilizado para abrir e fechar recursos de forma automática e segura. Ele é especialmente útil quando você trabalha com objetos que gerenciam recursos externos, como conexões com bancos de dados, arquivos, streams e outros objetos que implementam a interface IDisposable.

Como funciona?
Quando você usa o using, o C# garante que o recurso será liberado (fechado) automaticamente assim que o bloco de código terminar sua execução. Isso é feito chamando o método Dispose() do objeto, que é responsável por liberar o recurso, como fechar um arquivo ou uma conexão com banco de dados.

Exemplos de "abrir e fechar" recursos com using:
1- Abrir e fechar uma conexão com banco de dados:

using (SqlConnection connection = new SqlConnection(connectionString))
{
    connection.Open(); // Abre a conexão
    // Executar operações no banco de dados
} // Aqui a conexão é automaticamente fechada ao sair do bloco

2- Abrir e fechar um arquivo:


using (StreamReader reader = new StreamReader("meuarquivo.txt"))
{
    string linha = reader.ReadLine(); // Lê uma linha do arquivo
    Console.WriteLine(linha);
} // O arquivo é fechado automaticamente aqui

3- Abrir e fechar uma transação de banco de dados:

using (SqlConnection connection = new SqlConnection(connectionString))
{
    connection.Open();
    using (SqlTransaction transaction = connection.BeginTransaction())
    {
        // Executar comandos dentro da transação
        transaction.Commit(); // Ou Rollback em caso de erro
    } // A transação é automaticamente descartada aqui
} // A conexão é fechada aqui

Por que é útil?
Segurança: Garante que o recurso será liberado, mesmo que uma exceção ocorra dentro do bloco using.
Simplicidade: Elimina a necessidade de chamar manualmente métodos como Close() ou Dispose(), o que torna o código mais limpo e fácil de manter.
Resumo:
Sim, o using em C# é usado para abrir e fechar recursos de forma automática e segura, garantindo que tudo seja liberado corretamente quando não for mais necessário. Isso é particularmente útil para gerenciar conexões de banco de dados, arquivos, e outros recursos que exigem um controle explícito de abertura e fechamento.
_______________________________________________________________________________________________________________________________________________________________________

* STRINGS:
* GUID: Em C#, um GUID (Globally Unique Identifier) é um identificador único de 128 bits, representado como uma string de 32 caracteres hexadecimais. Ele é usado para garantir a unicidade de objetos, registros ou instâncias, especialmente em sistemas distribuídos.

Para gerar um GUID em C#, usa-se o método Guid.NewGuid():

Guid novoGuid = Guid.NewGuid();
Console.WriteLine(novoGuid);

USOS COMUNS:
- Chaves primárias em bancos de dados.
- Identificação única de objetos em sistemas distribuídos.
- Tokens de autenticação.
GUIDs são úteis para evitar colisões de identificadores, mas ocupam mais espaço (16 bytes) em comparação com inteiros e podem ter um desempenho ligeiramente inferior.
_______________________________________________________________________________________________________________________________________________________________________

* COMPARE TO: O método CompareTo é utilizado para comparar o valor de um objeto com outro.
Retorna um valor inteiro:
Valor negativo: Se o objeto atual é "menor" que o outro objeto.
Valor zero: Se o objeto atual é igual ao outro objeto.
Valor positivo: Se o objeto atual é "maior" que o outro objeto.
Este método é comumente usado com tipos que implementam a interface IComparable, como strings, números e datas.
Exemplo:

int result = 5.CompareTo(10); // result será negativo (-1) porque 5 é menor que 10
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

* CONTAINS: O método Contains é usado para verificar se um determinado elemento existe dentro de uma coleção ou estrutura de dados, como listas, arrays ou strings.
Retorna um valor booleano (true ou false):
true: Se o elemento ou substring for encontrado.
false: Caso contrário.

Exemplo:
string texto = "Olá, mundo!";
bool existe = texto.Contains("mundo"); // existe será true, porque "mundo" está na string

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
RESUMINDO:
CompareTo: Compara dois objetos e retorna um valor que indica a ordem entre eles.
Contains: Verifica se um elemento ou substring existe em uma coleção ou string.
- StringComparison.OrdinalIgnoreCase :Igonora o Case sensitive.
_______________________________________________________________________________________________________________________________________________________________________

* STARTSWITH:
- Objetivo: Verifica se a string começa com uma substring específica.
Retorno: Retorna true se a string começar com a substring fornecida, caso contrário, retorna false.
Sensível a maiúsculas/minúsculas: Por padrão, o método é sensível a maiúsculas e minúsculas. Você pode usar uma sobrecarga para ignorar essa diferenciação.
Exemplo:

string texto = "Exemplo de texto";
Console.WriteLine(texto.StartsWith("Exemplo")); // Saída: true
Console.WriteLine(texto.StartsWith("exemplo")); // Saída: false (sensível ao caso) 
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

* ENDSWITH:
- Objetivo: Verifica se a string termina com uma substring específica.
Retorno: Retorna true se a string terminar com a substring fornecida, caso contrário, retorna false.
Sensível a maiúsculas/minúsculas: Por padrão, o método também é sensível a maiúsculas e minúsculas. Há uma sobrecarga para fazer uma comparação ignorando o caso.
Exemplo:

string texto = "Exemplo de texto";
Console.WriteLine(texto.EndsWith("texto")); // Saída: true
Console.WriteLine(texto.EndsWith("Texto")); // Saída: false (sensível ao caso)

Sobre as sobrecargas:
Ambos os métodos (StartsWith e EndsWith) possuem uma sobrecarga que permite especificar um tipo de comparação, como StringComparison.CurrentCultureIgnoreCase, para ignorar diferenças de maiúsculas e minúsculas.

Exemplo com comparação que ignora o caso:

Console.WriteLine(texto.StartsWith("exemplo", StringComparison.OrdinalIgnoreCase)); // Saída: true
Console.WriteLine(texto.EndsWith("TEXTO", StringComparison.OrdinalIgnoreCase)); // Saída: true
_______________________________________________________________________________________________________________________________________________________________________

* EQUALS: Em C#, o método Equals é usado para comparar dois objetos e determinar se eles são iguais. Ele pode ser sobrecarregado para fornecer diferentes lógicas de comparação, dependendo do tipo de objeto.

Por padrão, o método Equals compara as referências dos objetos (ou seja, verifica se os dois objetos apontam para o mesmo local na memória). No entanto, muitas classes em C# (como string, int, etc.) sobrecarregam o método Equals para realizar uma comparação baseada no conteúdo dos objetos, e não nas referências.

Exemplo básico:

csharp
Copiar código
int a = 5;
int b = 5;
Console.WriteLine(a.Equals(b));  // Retorna true, porque os valores são iguais

Para objetos personalizados, você pode sobrecarregar o método Equals para definir como os objetos devem ser comparados:

public class Pessoa
{
    public string Nome { get; set; }

    public override bool Equals(object obj)
    {
        if (obj is Pessoa outraPessoa)
        {
            return this.Nome == outraPessoa.Nome;
        }
        return false;
    }

    public override int GetHashCode()
    {
        return Nome?.GetHashCode() ?? 0;
    }
}

Nessa sobrecarga, duas instâncias da classe Pessoa serão consideradas iguais se seus nomes forem iguais.

Dica: Ao sobrecarregar Equals, é importante também sobrecarregar o método GetHashCode, para garantir que objetos iguais tenham o mesmo código hash, especialmente quando usados em coleções como HashSet ou Dictionary.
_______________________________________________________________________________________________________________________________________________________________________

* ÍNDICES: Em C#, índices são usados para acessar elementos de coleções como arrays, listas e strings. O índice é uma posição numérica que indica a localização de um item dentro da coleção.

Principais Aspectos sobre Índices:

Arrays: O índice começa em 0 e vai até o tamanho do array menos 1.

int[] arr = { 10, 20, 30 };
Console.WriteLine(arr[0]); // Saída: 10
Listas:

Semelhante aos arrays, as listas também utilizam índices.

List<int> lista = new List<int> { 10, 20, 30 };
Console.WriteLine(lista[1]); // Saída: 20
Índice de Valor (Introduzido no C# 8.0):

Permite acessar elementos a partir do final da coleção, usando o ^.

int[] arr = { 10, 20, 30, 40 };
Console.WriteLine(arr[^1]); // Saída: 40 (último elemento)
Strings:

Strings podem ser indexadas como arrays de caracteres.

string texto = "CSharp";
Console.WriteLine(texto[0]); // Saída: 'C'
Métodos IndexOf e LastIndexOf:
IndexOf: Localiza a primeira ocorrência de um valor em uma coleção (array, lista, ou string). Retorna o índice da primeira ocorrência ou -1 se não encontrar.

int[] arr = { 10, 20, 30, 40, 30 };
Console.WriteLine(Array.IndexOf(arr, 30)); // Saída: 2
LastIndexOf: Localiza a última ocorrência de um valor em uma coleção. Retorna o índice da última ocorrência ou -1 se não encontrar.

int[] arr = { 10, 20, 30, 40, 30 };
Console.WriteLine(Array.LastIndexOf(arr, 30)); // Saída: 4
Exemplos com Strings:
IndexOf: Retorna o índice da primeira ocorrência de um caractere ou substring.

string texto = "CSharp";
Console.WriteLine(texto.IndexOf('S')); // Saída: 1
LastIndexOf: Retorna o índice da última ocorrência de um caractere ou substring.

string texto = "Aprenda CSharp!";
Console.WriteLine(texto.LastIndexOf("CSharp")); // Saída: 8

Resumo:
Índices são fundamentais para acessar elementos em coleções.
IndexOf encontra a primeira ocorrência e LastIndexOf encontra a última ocorrência de um valor em coleções.
Ambos retornam o índice do valor ou -1 se não encontrado.
_______________________________________________________________________________________________________________________________________________________________________

* TOUPPER e TOLOWER: Em C#, os métodos ToUpper e ToLower são utilizados para converter todos os caracteres de uma string para maiúsculas ou minúsculas, respectivamente. Ambos fazem parte da classe string, que oferece uma série de métodos para manipulação de texto.

* ToUpper(): O método ToUpper() converte todos os caracteres de uma string para maiúsculas. Ele não altera a string original, pois as strings em C# são imutáveis. Em vez disso, ele retorna uma nova string com todas as letras em maiúsculas.

Exemplo:

string texto = "Exemplo de Texto";
string textoMaiusculo = texto.ToUpper();

Console.WriteLine(textoMaiusculo); // Saída: "EXEMPLO DE TEXTO"

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
* ToLower():  método ToLower() converte todos os caracteres de uma string para minúsculas. Assim como o ToUpper(), ele não modifica a string original, mas retorna uma nova string com as letras em minúsculas.

Exemplo:


string texto = "Exemplo de Texto";
string textoMinusculo = texto.ToLower();

Console.WriteLine(textoMinusculo); // Saída: "exemplo de texto"



Em C#, os métodos ToUpper e ToLower são utilizados para converter todos os caracteres de uma string para maiúsculas ou minúsculas, respectivamente. Ambos fazem parte da classe string, que oferece uma série de métodos para manipulação de texto.

Aqui está uma explicação detalhada de cada um:

ToUpper()
O método ToUpper() converte todos os caracteres de uma string para maiúsculas. Ele não altera a string original, pois as strings em C# são imutáveis. Em vez disso, ele retorna uma nova string com todas as letras em maiúsculas.

Exemplo:

csharp
Copiar código
string texto = "Exemplo de Texto";
string textoMaiusculo = texto.ToUpper();

Console.WriteLine(textoMaiusculo); // Saída: "EXEMPLO DE TEXTO"
ToLower()
O método ToLower() converte todos os caracteres de uma string para minúsculas. Assim como o ToUpper(), ele não modifica a string original, mas retorna uma nova string com as letras em minúsculas.

Exemplo:

csharp
Copiar código
string texto = "Exemplo de Texto";
string textoMinusculo = texto.ToLower();

Console.WriteLine(textoMinusculo); // Saída: "exemplo de texto"
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

Detalhes importantes:
Imutabilidade de strings: Como mencionado, as strings em C# são imutáveis. Isso significa que métodos como ToUpper() e ToLower() retornam uma nova string, sem modificar a original.

Uso comum: Esses métodos são frequentemente usados em comparações de strings, como quando se quer fazer uma comparação sem diferenciar maiúsculas e minúsculas, ou quando se quer formatar uma string de forma consistente (por exemplo, em formulários ou busca por palavras).

Sensibilidade a localidade: Ambos os métodos (ToUpper e ToLower) dependem da cultura atual do sistema. Isso significa que, em algumas culturas (como o turco), certos caracteres podem ser tratados de maneira diferente. Para evitar problemas de localidade, você pode usar uma sobrecarga desses métodos que permite especificar uma cultura específica.

Exemplo de cultura específica:

csharp
Copiar código
string texto = "i";
string textoMaiusculo = texto.ToUpper(System.Globalization.CultureInfo.InvariantCulture);

Console.WriteLine(textoMaiusculo); // Saída: "I" (A letra "i" é maiúscula de forma consistente, independentemente da cultura)
Resumo:
ToUpper() converte todos os caracteres de uma string para maiúsculas.
ToLower() converte todos os caracteres de uma string para minúsculas.
Ambos os métodos retornam uma nova string com a alteração e não alteram a string original.
_______________________________________________________________________________________________________________________________________________________________________

* REMOVE(): O método Remove() é usado para remover uma parte de uma string, a partir de um índice específico até o final ou até um número determinado de caracteres.

Sintaxe:
string Remove(int startIndex) // Remove todos os caracteres a partir do índice especificado até o final
string Remove(int startIndex, int count) // Remove "count" caracteres a partir do índice especificado

Exemplo:
string texto = "Exemplo de texto";
string resultado = texto.Remove(7); // Remove a partir do índice 7 até o final
Console.WriteLine(resultado); // Saída: "Exemplo"

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

* LENGTH(): O método Length é uma propriedade que retorna o número de caracteres em uma string (incluindo espaços).

Exemplo:
string texto = "Exemplo";
int tamanho = texto.Length; // Retorna 7, pois "Exemplo" tem 7 caracteres
Console.WriteLine(tamanho); // Saída: 7
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

RESUMO:
Remove(): Remove uma parte da string, começando de um índice específico e, opcionalmente, removendo um número definido de caracteres.
Length: Retorna o número total de caracteres em uma string.
_______________________________________________________________________________________________________________________________________________________________________

* REPLACE(): Substitui todas as ocorrências de um valor por outro em uma string.
Exemplo:
csharp
Copiar código
string texto = "Olá Mundo!";
string resultado = texto.Replace("Mundo", "C#"); // "Olá C#!"

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
*SPLIT(): Divide uma string em um array de substrings com base em um delimitador especificado.
Exemplo:
csharp
Copiar código
string texto = "maçã,banana,laranja";
string[] partes = texto.Split(','); // ["maçã", "banana", "laranja"]

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
* SUBSTRING(): Retorna uma parte de uma string, começando em um índice especificado e com um comprimento opcional.
Exemplo:
csharp
Copiar código
string texto = "Exemplo";
string parte = texto.Substring(1, 4); // "xemp"

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
* TRIM(): Remove espaços em branco do início e do fim de uma string.
Exemplo:
csharp
Copiar código
string texto = "  Olá Mundo!  ";
string resultado = texto.Trim(); // "Olá Mundo!"
_______________________________________________________________________________________________________________________________________________________________________

* STRINGBILDER(): O StringBuilder em C# é uma classe da biblioteca padrão que serve para criar e manipular strings de forma eficiente, especialmente quando há necessidade de modificar ou concatenar muitas strings em sequência. Isso ocorre porque, ao contrário do tipo string comum, que é imutável (ou seja, a cada alteração cria uma nova instância de string), o StringBuilder permite modificações no conteúdo da string sem criar novas instâncias, o que melhora o desempenho em situações de processamento intensivo de strings.

Características principais:
Eficiência: O StringBuilder reduz o custo de tempo e memória ao modificar strings repetidamente.
Mutabilidade: Ele permite adicionar, substituir e remover caracteres ou substrings sem criar novos objetos toda vez.
Capacidade ajustável: A capacidade interna do StringBuilder pode crescer conforme necessário, e você pode pré-definir sua capacidade inicial para evitar realocações frequentes.

Exemplo de uso:
using System;
using System.Text;

class Program
{
    static void Main()
    {
        StringBuilder sb = new StringBuilder("Olá");
        sb.Append(" Mundo");
        sb.AppendLine("!");
        sb.Replace("Mundo", "C#");

        Console.WriteLine(sb.ToString());  // Saída: Olá C#!
    }
}
Neste exemplo, o StringBuilder começa com "Olá", e depois adiciona " Mundo", uma nova linha, e faz uma substituição de "Mundo" por "C#". O resultado final é impresso com um bom desempenho.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

* APPEND():  método Append() em C# é usado com a classe StringBuilder para adicionar (concatenar) texto ao final de uma string existente de forma eficiente. Quando você usa o Append(), ele modifica o conteúdo do StringBuilder, acrescentando a string especificada ao final da string atual.

Características do Append():
Eficiência: Como o StringBuilder é mutável, usar Append() não cria uma nova instância de string toda vez, como ocorre com o tipo string comum, o que torna essa operação mais eficiente.
Uso de diferentes tipos de dados: O Append() pode ser usado com qualquer tipo de dado (não apenas strings), como números, objetos, caracteres, etc. Ele irá automaticamente converter esses valores para string antes de adicionar ao StringBuilder.
Exemplo de uso:
csharp
Copiar código
using System;
using System.Text;

class Program
{
    static void Main()
    {
        StringBuilder sb = new StringBuilder("Olá");

        // Adiciona mais texto ao final
        sb.Append(" Mundo");
        sb.Append("!");

        Console.WriteLine(sb.ToString());  // Saída: Olá Mundo!
    }
}
No exemplo acima, o método Append() é usado para adicionar " Mundo" e "!" à string inicial "Olá", resultando em "Olá Mundo!".

Sobre o método:
Sintaxe: sb.Append(valor)
valor: O texto ou valor a ser adicionado.
Ele retorna o próprio objeto StringBuilder, o que permite encadear várias chamadas de Append() em uma única linha.
Exemplo com diferentes tipos:
csharp
Copiar código
StringBuilder sb = new StringBuilder();
sb.Append("Número: ");
sb.Append(42);  // Adiciona o número 42 como string
Console.WriteLine(sb.ToString());  // Saída: Número: 42
Neste exemplo, Append(42) adiciona o número 42, automaticamente convertido para "42", à string.
_______________________________________________________________________________________________________________________________________________________________________

* DATAIME: Em C#, o DateTime é uma estrutura que representa um ponto no tempo, combinando a data (ano, mês, dia) e a hora (hora, minuto, segundo, milissegundo). O tipo DateTime é muito utilizado para manipulação e formatação de datas e horas.

O Tipo DateTime em C#
O DateTime é usado para representar tanto a data quanto a hora, e ele oferece uma série de métodos e propriedades para facilitar a manipulação desses valores.

Criação de um Objeto DateTime
Você pode criar objetos DateTime de diversas formas:

Data e hora específicas:

csharp
Copiar código
DateTime dt1 = new DateTime(2024, 12, 6, 15, 30, 0); // 6 de Dezembro de 2024, 15:30:00
Console.WriteLine(dt1);  // Saída: 06/12/2024 15:30:00
Usando o DateTime.Now para obter a data e hora atuais:

csharp
Copiar código
DateTime dt2 = DateTime.Now;  // Pega a data e hora atual do sistema
Console.WriteLine(dt2);  // Saída: data e hora atual do sistema
Usando o DateTime.Today para pegar a data atual sem a hora:

csharp
Copiar código
DateTime dt3 = DateTime.Today;  // Apenas a data de hoje, hora é 00:00
Console.WriteLine(dt3);  // Saída: 06/12/2024 00:00:00
Propriedades do DateTime
O DateTime possui várias propriedades úteis para acessar partes da data e hora:

Year: Obtém o ano da data.

csharp
Copiar código
int ano = dt1.Year;
Month: Obtém o mês (1 a 12).

csharp
Copiar código
int mes = dt1.Month;
Day: Obtém o dia do mês.

csharp
Copiar código
int dia = dt1.Day;
Hour: Obtém a hora do dia.

csharp
Copiar código
int hora = dt1.Hour;
Minute: Obtém o minuto.

csharp
Copiar código
int minuto = dt1.Minute;
Second: Obtém o segundo.

csharp
Copiar código
int segundo = dt1.Second;
DayOfWeek: Obtém o dia da semana como um valor enumerado (Sunday, Monday, etc).

csharp
Copiar código
DayOfWeek diaSemana = dt1.DayOfWeek;
DayOfYear: Obtém o número do dia no ano (1 a 365/366).

csharp
Copiar código
int diaDoAno = dt1.DayOfYear;
Métodos Comuns para Manipulação de DateTime
Adicionar ou subtrair intervalos de tempo:

AddDays(), AddMonths(), AddYears(), AddHours(), etc.
csharp
Copiar código
DateTime dtFuturo = dt1.AddDays(10);  // Adiciona 10 dias
Console.WriteLine(dtFuturo);  // Saída: 16/12/2024 15:30:00
Subtract() para subtrair um DateTime de outro:
csharp
Copiar código
TimeSpan intervalo = dt1.Subtract(dt2);  // Diferença entre duas datas
Console.WriteLine(intervalo.TotalDays);  // Saída: número total de dias entre as duas datas
Comparando datas: Você pode usar métodos como Equals(), CompareTo() ou operadores (<, >, ==, etc.) para comparar instâncias de DateTime.

csharp
Copiar código
bool igual = dt1.Equals(dt2);  // Verifica se são iguais
Formatação de DateTime
Você pode formatar um objeto DateTime em uma string usando o método ToString(). Existem diversos formatos pré-definidos ou você pode criar seu próprio formato.

Formatos predefinidos:


DateTime dt = DateTime.Now;
Console.WriteLine(dt.ToString("yyyy-MM-dd"));  // Formato: 2024-12-06
Console.WriteLine(dt.ToString("MM/dd/yyyy"));  // Formato: 12/06/2024
Console.WriteLine(dt.ToString("HH:mm:ss"));  // Formato: 15:30:45
Formatos personalizados: Você também pode criar um formato específico:

csharp
Copiar código
Console.WriteLine(dt.ToString("dddd, dd MMMM yyyy HH:mm:ss"));  // Ex: "Friday, 06 December 2024 15:30:45"
Outras Formatações Comuns:
d - Data curta (ex: 06/12/2024).
D - Data longa (ex: Friday, December 6, 2024).
t - Hora curta (ex: 15:30).
T - Hora longa (ex: 15:30:45).
Manipulação de Tempo com TimeSpan
O TimeSpan é usado para representar a diferença entre duas instâncias de DateTime, ou para adicionar ou subtrair períodos de tempo. Por exemplo:

csharp
Copiar código
DateTime dt1 = new DateTime(2024, 12, 6, 10, 0, 0);
DateTime dt2 = new DateTime(2024, 12, 6, 14, 30, 0);
TimeSpan intervalo = dt2 - dt1;
Console.WriteLine(intervalo);  // Saída: 04:30:00 (4 horas e 30 minutos)
Conclusão
Em resumo, o tipo DateTime em C# é extremamente útil para trabalhar com datas e horas. Ele oferece uma ampla gama de funcionalidades para criação, formatação, manipulação e comparação de datas e horas. Além disso, a combinação com o tipo TimeSpan permite manipular intervalos de tempo entre dois pontos no calendário.








 











  






